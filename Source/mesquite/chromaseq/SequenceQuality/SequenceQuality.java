package mesquite.chromaseq.SequenceQuality;

import mesquite.categ.lib.MolecularState;
import mesquite.chromaseq.lib.ChromaseqBaseMapper;
import mesquite.chromaseq.lib.ChromaseqUtil;
import mesquite.cont.lib.ContinuousData;
import mesquite.lib.EmployeeNeed;
import mesquite.lib.MesquiteModule;
import mesquite.lib.MesquiteNumber;
import mesquite.lib.MesquiteString;
import mesquite.lib.Notification;
import mesquite.lib.Taxa;
import mesquite.lib.Taxon;
import mesquite.lib.characters.CharacterData;
import mesquite.lib.characters.MCharactersDistribution;
import mesquite.lib.duties.MatrixSourceCoord;
import mesquite.lib.duties.NumberForTaxon;

	public class SequenceQuality extends NumberForTaxon {
		public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed
			EmployeeNeed e = registerEmployeeNeed(MatrixSourceCoord.class, getName() + "  needs a source of sequences.",
			"The source of characters is arranged initially");
		}
		MatrixSourceCoord matrixSourceTask;
		Taxa currentTaxa = null;
		MCharactersDistribution observedStates =null;
		ChromaseqBaseMapper chromMapper;
		ContinuousData linkedData;
		CharacterData data;


		/*.................................................................................................................*/
		public boolean startJob(String arguments, Object condition, boolean hiredByName) {
			matrixSourceTask = (MatrixSourceCoord)hireCompatibleEmployee(MatrixSourceCoord.class, MolecularState.class, "Source of character matrix (for " + getName() + ")"); 
			if (matrixSourceTask==null)
				return sorry(getName() + " couldn't start because no source of character matrices was obtained.");
			return true;
		}

		/*.................................................................................................................*/
		/** Generated by an employee who quit.  The MesquiteModule should act accordingly. */
		public void employeeQuit(MesquiteModule employee) {
			if (employee == matrixSourceTask)  // character source quit and none rehired automatically
				iQuit();
		}
		/*.................................................................................................................*/
		public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {
			observedStates = null;
			super.employeeParametersChanged(employee, source, notification);
		}
		/*.................................................................................................................*/
		/** returns whether this module is requesting to appear as a primary choice */
		public boolean requestPrimaryChoice(){
			return true;  
		}

		/** Called to provoke any necessary initialization.  This helps prevent the module's initialization queries to the user from
	   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/
		public void initialize(Taxa taxa){
			currentTaxa = taxa;
			matrixSourceTask.initialize(currentTaxa);
			observedStates = matrixSourceTask.getCurrentMatrix(taxa);
			data = observedStates.getParentData();
			
			linkedData = ChromaseqUtil.getQualityData(data);
			chromMapper = new ChromaseqBaseMapper(data);

		}
		
	   	int count = 0;
	   	double summ = 0;
	   	private double getQualityTaxon(int it){
	   		if (data == null)
	   			return 0;
	   		if (linkedData == null)
	   			return 0;
	    		double sum = 0;
	   		for (int ic = 0; ic<linkedData.getNumChars(false); ic++){
	   			if (!data.isUnassigned(ic, it) && !linkedData.isUnassigned(ic, it)) {
	   				double d = chromMapper.getQualityScore(ic, it);
	   				if (d>101)
	   					;
	   				else if (d>=90.0)
	   					sum += 1;
	   				else if (d>=80.0)
	   					sum += 0.9;
	   				else if (d>=70.0)
	   					sum += 0.7;
	   				else if (d>=60.0)
	   					sum += 0.5;
	   				else if (d>=50.0)
	   					sum += 0.4;
	   				else if (d>=40.0)
	   					sum += 0.2;
	   				else
	   					sum += 1/(100.0 - d); //count good states more!
	   					//sum += 1/((100.0 - d)*(100.0 - d)); //count good states more!
	   			}
	   		}
	   		summ = sum;
	   		return sum*50/linkedData.getNumChars(false);
	   		/*
	   		Object obj = data.getCellObject(qualityNameRef, ic, it);//IF USED use  ChromaseqUtil.getIntegerCellObject
	   		if (obj instanceof MesquiteInteger)
	   			return ((MesquiteInteger)obj).getValue();
	   		return 0;
	   		*/
	   	}


		public void calculateNumber(Taxon taxon, MesquiteNumber result, MesquiteString resultString){
			if (result==null)
				return;
			result.setToUnassigned();
			clearResultAndLastResult(result);
			Taxa taxa = taxon.getTaxa();
			int it = taxa.whichTaxonNumber(taxon);
			if (taxa != currentTaxa || observedStates == null ) {
				observedStates = matrixSourceTask.getCurrentMatrix(taxa);
				currentTaxa = taxa;
			}
			if (observedStates==null)
				return;
			data = observedStates.getParentData();
			linkedData = ChromaseqUtil.getQualityData(data);
			chromMapper = new ChromaseqBaseMapper(data);

			double qualityScore = getQualityTaxon(it);

			result.setValue(qualityScore);
		
		
			if (resultString!=null)
				resultString.setValue("Quality of sequence in matrix "+ observedStates.getName()  + ": " + result.toString());
			saveLastResult(result);
			saveLastResultString(resultString);
		}
		/*.................................................................................................................*/
		public String getName() {
			if (currentTaxa != null && observedStates == null)
				observedStates = matrixSourceTask.getCurrentMatrix(currentTaxa);
			if (observedStates != null && getProject().getNumberCharMatrices()>1){
				CharacterData d = observedStates.getParentData();
				if (d != null && d.getName()!= null) {
					String n =  d.getName();
					if (n.length()>12)
						n = n.substring(0, 12); 
					return "Qual.Score (" + n + ")";
				}
			}
			return "Quality Score";
		}

		/*.................................................................................................................*/
		public boolean isPrerelease() {
			return false;
		}
		public String getParameters() {
			return "Sequence quality in matrix from: " + matrixSourceTask.getParameters();
		}
		/*.................................................................................................................*/

		/** returns an explanation of what the module does.*/
		public String getExplanation() {
			return "Reports a measure of sequence quality as judged by Phred/Phrap scores, for a molecular sequence in a taxon." ;
		}

	}



