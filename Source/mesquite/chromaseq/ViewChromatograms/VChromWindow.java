/* Mesquite chromaseq source code.  Copyright 2005-2006 D. Maddison and W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms;import java.io.*;import java.util.*;import java.net.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.table.*;import mesquite.lib.characters.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.chromaseq.lib.*;import mesquite.lib.duties.*;//Todo: This and contained panels should be within ViewChromatograms as they are designed to be used by only that one module/* ======================================================================== */public class VChromWindow extends ChromatWindow implements MesquiteListener {	String title;	int vMargin = 20;	MesquiteTable table; //data matrix table	DNAData data;	DNAData originalData;	ContinuousData qualityData;	int defaultWidth = 1000;	int defaultHeight = 400;	MesquiteModule viewModule;	MesquiteBoolean showControls;	MesquiteBoolean colorByQuality;	MesquiteBoolean thickTrace = new MesquiteBoolean (ChromatogramPanel.THICKTRACEDEFAULT);	MesquiteBoolean fadeLowQuality;	MesquiteBoolean fadeNonSourceRead;	MesquiteBoolean fadeNonSourceLowerQualityRead;	MesquiteBoolean showReadMatrixConflict = new MesquiteBoolean (ChromatogramPanel.SHOWREADMATRIXCONFLICTDEFAULT);	MesquiteBoolean showReadReadConflict;	MesquiteBoolean showLowerQualSourceConflictsWithHigherQualRead;	MesquiteBoolean showReadName;	MesquiteBoolean dimLowQualityConflicts;	MesquiteInteger fadeLowQualityThreshold;	MesquiteInteger dimConflictMarkerThreshold;	MesquiteInteger jumpQualityThreshold;	MesquiteInteger jumpConflictThreshold;	MesquiteBoolean showA;	MesquiteBoolean showC;	MesquiteBoolean showG;	MesquiteBoolean showT;	MesquiteBoolean scrollToTouched = new MesquiteBoolean(false);	MesquiteBoolean showBaseSource = new MesquiteBoolean(true);	MesquiteBoolean showCodonPosition = new MesquiteBoolean(false);	MesquiteBoolean viewChromatograms = new MesquiteBoolean(true);	MesquiteBoolean viewOverview = new MesquiteBoolean(false);	MesquiteBoolean showFades = new MesquiteBoolean(true);	public Color AColor = Color.green;	public Color CColor = Color.blue;	public Color GColor = Color.black;	public Color TColor = Color.red;	Color backgroundColor = Color.white;	MesquiteBoolean jumpToNextBase = new MesquiteBoolean(false);	MesquiteBoolean jumpToNextReadReadConflict = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextReadMatrixConflict = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextLowQuality = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextAmbiguity = new MesquiteBoolean(true);	MesquiteBoolean jumpToNextBadSourceRead = new MesquiteBoolean(true);	static Image leftArrow, rightArrow;	ContigPanel contigPanel;	Vector extraContigs;	MesquiteModule windowServer;	MesquiteBoolean showPrimerMatches = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWPRIMERS);	MesquiteBoolean showSinglePrimerMatch = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWSINGLEPRIMERMATCH);	MesquiteBoolean sequencesLocked = new MesquiteBoolean(false);		MesquiteString singlePrimer = new MesquiteString("");	public VChromWindow(MesquiteModule module, MesquiteModule windowServer, MesquiteTable table, CharacterData data, Taxon taxon, String title, Chromatogram[] chroms, Contig contig, Read[] reads) {			super(windowServer, false);		this.windowServer = windowServer;		this.viewModule = module;	//	setVisible(false);		extraContigs = new Vector();		setWindowSize(defaultWidth, defaultHeight + 16+36);		if (leftArrow == null){			leftArrow = MesquiteImage.getImage(module.getPath()+"arrowLeft.gif");			rightArrow = MesquiteImage.getImage(module.getPath()+"arrowRight.gif");		}
		//windowServer.addMenuItem(null, "Reverse Complement", MesquiteModule.makeCommand("reverseComplement", this));
		showControls = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Control Bar", MesquiteModule.makeCommand("showControls", this), showControls);		windowServer.addMenuItem("Show Matrix", MesquiteModule.makeCommand("showMatrix", this));
		colorByQuality = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Color By Quality", MesquiteModule.makeCommand("toggleColorByQuality", this), colorByQuality);		windowServer.addCheckMenuItem(null, "Thick Trace Lines", MesquiteModule.makeCommand("toggleThickTrace", this), thickTrace);				windowServer.addMenuLine();		MesquiteMenuItemSpec	mm = windowServer.addMenuItem("Show Fades", MesquiteModule.makeCommand("toggleFades", this));//		MesquiteMenuItemSpec	mm = windowServer.addCheckMenuItem(null, "Show Fades", MesquiteModule.makeCommand("toggleFades", this), showFades);		mm.setShortcut(KeyEvent.VK_D); 		fadeLowQuality = new MesquiteBoolean(false);		windowServer.addCheckMenuItem(null, "Fade Low Quality", MesquiteModule.makeCommand("toggleFadeLowQuality", this), fadeLowQuality);		fadeLowQualityThreshold = new MesquiteInteger(20);		windowServer.addMenuItem( "Fade Quality Threshold...", MesquiteModule.makeCommand("setFadeThreshold",  this));		fadeNonSourceRead = new MesquiteBoolean(false);		windowServer.addCheckMenuItem(null, "Fade Non-Source Read", MesquiteModule.makeCommand("toggleFadeNonSourceRead", this), fadeNonSourceRead);		fadeNonSourceLowerQualityRead = new MesquiteBoolean(false);  //DavidJan07: OK?		windowServer.addCheckMenuItem(null, "Fade Non-Source Lower-Quality Read", MesquiteModule.makeCommand("toggleFadeNonSourceLowerQualityRead", this), fadeNonSourceLowerQualityRead);		dimLowQualityConflicts = new MesquiteBoolean(true);		windowServer.addMenuLine();		showLowerQualSourceConflictsWithHigherQualRead = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleShowLowerQualSourceConflictsWithHigherQualRead", this), showLowerQualSourceConflictsWithHigherQualRead);		windowServer.addCheckMenuItem(null, "Show Read-Matrix Conflict", MesquiteModule.makeCommand("toggleShowChromMatrixDisagreement", this), showReadMatrixConflict);		showReadReadConflict = new MesquiteBoolean(true);		windowServer.addCheckMenuItem(null, "Show Read-Read Conflict", MesquiteModule.makeCommand("toggleShowReadReadConflict", this), showReadReadConflict);		windowServer.addCheckMenuItem(null, "Dim Conflict Markers if Low Quality", MesquiteModule.makeCommand("toggleDimLowQualityConflicts", this), dimLowQualityConflicts);		dimConflictMarkerThreshold = new MesquiteInteger(30);		windowServer.addMenuItem( "Dim Conflict Marker Threshold...", MesquiteModule.makeCommand("setDimConflictMarkerTheshold",  this));		windowServer.addMenuLine();		//^^^^single contig		MesquiteSubmenuSpec viewSubmenu = windowServer.addSubmenu(null, "View");		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Chromatograms", MesquiteModule.makeCommand("toggleViewChromatograms",  this), viewChromatograms);		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Overview", MesquiteModule.makeCommand("toggleViewOverview",  this), viewOverview);		//^^^^^^^^^^^^^		showReadName = new MesquiteBoolean(true);		MesquiteSubmenuSpec mss = windowServer.addSubmenu(null, "Show");		showA = new MesquiteBoolean(true);		showC = new MesquiteBoolean(true);		showG = new MesquiteBoolean(true);		showT = new MesquiteBoolean(true);		windowServer.addCheckMenuItemToSubmenu(null, mss, "A Trace", MesquiteModule.makeCommand("toggleShowA",  this), showA);		windowServer.addCheckMenuItemToSubmenu(null, mss, "C Trace", MesquiteModule.makeCommand("toggleShowC",  this), showC);		windowServer.addCheckMenuItemToSubmenu(null, mss, "G Trace", MesquiteModule.makeCommand("toggleShowG",  this), showG);		windowServer.addCheckMenuItemToSubmenu(null, mss, "T Trace", MesquiteModule.makeCommand("toggleShowT",  this), showT);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Base Source", MesquiteModule.makeCommand("toggleShowBaseSource", this), showBaseSource);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Codon Position", MesquiteModule.makeCommand("toggleShowCodonPosition", this), showCodonPosition);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Read Name", MesquiteModule.makeCommand("toggleShowReadName", this), showReadName);		windowServer.addCheckMenuItem(null, "Center Where Touched", MesquiteModule.makeCommand("toggleScrollToTouched", this), scrollToTouched);		MesquiteSubmenuSpec navSubmenu = windowServer.addSubmenu(null, "Arrow Keys");		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Move To Next Base", MesquiteModule.makeCommand("toggleJumpToNextBase",  this), jumpToNextBase);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleJumpToNextBadSource",  this), jumpToNextBadSourceRead);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Matrix Conflict", MesquiteModule.makeCommand("toggleJumpToNextReadMatrixConflict",  this), jumpToNextReadMatrixConflict);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Read Conflict", MesquiteModule.makeCommand("toggleJumpToNextConflict",  this), jumpToNextReadReadConflict);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Low Quality", MesquiteModule.makeCommand("toggleJumpToNextLowQuality",  this), jumpToNextLowQuality);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Ambiguity", MesquiteModule.makeCommand("toggleJumpToNextAmbiguity",  this), jumpToNextAmbiguity);		windowServer.addLineToSubmenu(null,navSubmenu);		jumpConflictThreshold = new MesquiteInteger(30);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Conflict Threshold...", MesquiteModule.makeCommand("setJumpConflictThreshold",  this));		jumpQualityThreshold = new MesquiteInteger(30);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Quality Threshold...", MesquiteModule.makeCommand("setJumpQualityThreshold",  this));		windowServer.addMenuItem("-",null);		MesquiteSubmenuSpec primerSubmenu = windowServer.addSubmenu(null, "Primers");		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu,"Show Primer Matches", MesquiteModule.makeCommand("showPrimerMatches",  this), showPrimerMatches);		windowServer.addItemToSubmenu(null, primerSubmenu, "Set Primer File ...", MesquiteModule.makeCommand("setPrimerSequenceFile",  this));		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu, "Show Single Primer Match", MesquiteModule.makeCommand("showSinglePrimerMatch",  this), showSinglePrimerMatch);		windowServer.addItemToSubmenu(null, primerSubmenu, "Specify Single Primer ...", MesquiteModule.makeCommand("setSinglePrimer",  this));				windowServer.addMenuItem( "Show Extra Sequence...", MesquiteModule.makeCommand("showExtraContig",  this));		windowServer.addCheckMenuItem( null, "Lock Extra sequences", MesquiteModule.makeCommand("lockSequences",  this), sequencesLocked);		windowServer.addMenuItem("-",null);		this.title = title;		this.table = table;		this.data = (DNAData)data;		setAnnotation(taxon.getName() + " (in matrix " + data.getName() + ")", null);		Vector links = data.getDataLinkages();		if (links != null){			for (int i=0; i<links.size(); i++){				CharacterData d = (CharacterData)links.elementAt(i);				if (d instanceof DNAData)					originalData = (DNAData)d;				else if(d instanceof ContinuousData)					qualityData = (ContinuousData)d;			}		}		if (originalData == null) {			originalData = (DNAData)data;		}		if (data != null)			data.addListener(this);		if (originalData != null)			originalData.addListener(this);		if (qualityData != null)			qualityData.addListener(this);		contigPanel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, true);		initializeContigPanelSettings(contigPanel);		addToWindow(contigPanel);		//infoPanel = new InfoPanel(taxon.getName());		//addToWindow(infoPanel);//		sizeDisplays()		ChromatogramTool arrowTool = new ChromatogramTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(),"arrow.gif", 4,2,"Select", "Selection tool", MesquiteModule.makeCommand("arrowTouch",  this) , MesquiteModule.makeCommand("arrowDrop",  this), null);		arrowTool.setIsArrowTool(true);		setShowAnnotation(true);		setShowExplanation(true);		addTool(arrowTool);		setCurrentTool(arrowTool);		arrowTool.setInUse(true);		resetTitle();		sizeDisplays();		SequencePanel[] sequences = new SequencePanel[]{contigPanel.aceContigPanel, contigPanel.origSeqPanel, contigPanel.matrixSeqPanel};		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).setWindow(this);				((ChromInit)e).addContext(taxon, contig, contigPanel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, contigPanel.getID());			}		}	}	void addContig(Taxon taxon, Chromatogram[] chroms, Contig contig, Read[] reads){		ContigPanel panel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, false);		initializeContigPanelSettings(panel);		SequencePanel[] sequences = new SequencePanel[]{panel.aceContigPanel, panel.origSeqPanel, panel.matrixSeqPanel};		extraContigs.addElement(panel);		addToWindow(panel);		panel.setVisible(true);		ContigControlPanel control = new ContigControlPanel(taxon.getName(), panel);		ContigLinkerPanel linker = new ContigLinkerPanel(panel);		panel.setLinker(linker);		addToWindow(linker);		panel.setControl(control);		addToWindow(control);		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).addContext(taxon, contig, panel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, panel.getID());			}		}		sizeDisplays();	}	void removeContig(ContigPanel panel){		extraContigs.removeElement(panel);		panel.setVisible(false);		ContigControlPanel control = panel.getControl();		control.setVisible(false);		removeFromWindow(panel);		removeFromWindow(control);		sizeDisplays();	}	void initializeContigPanelSettings(ContigPanel p){				p.setShowA(showA.getValue());				p.setShowC(showC.getValue());				p.setShowG(showG.getValue());				p.setShowT(showT.getValue());				p.setScrollToTouched(scrollToTouched.getValue());				p.setShowBaseSource(showBaseSource.getValue());				p.setShowCodonPosition(showCodonPosition.getValue());				p.setShowReadName(showReadName.getValue());			//	p.setShowBaseNumberWithinRead(showBaseNumberWithinRead.getValue());				p.setShowReadMatrixConflict(showReadMatrixConflict.getValue());				p.setShowReadReadConflict(showReadReadConflict.getValue());				p.setShowLowerQualSourceConflictsWithHigherQualRead(showLowerQualSourceConflictsWithHigherQualRead.getValue());				p.setDimConflictMarkerThreshold(dimConflictMarkerThreshold.getValue());				p.setDimLowQualityConflicts(dimLowQualityConflicts.getValue());				p.setFadeLowQuality(fadeLowQuality.getValue());				p.setShowFades(showFades.getValue());				p.setFadeNonSourceRead(fadeNonSourceRead.getValue());				p.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead.getValue());				p.setFadeQualityThreshold(fadeLowQualityThreshold.getValue());	}	/*.................................................................................................................*/	public static VChromWindow showChromatogram(Contig contig, MesquiteTable table, DNAData matrixData, Taxon taxon, VChromWindow existing, MesquiteModule windowServer, MesquiteModule ownerModule){//		Debugg.println("|||||||||||||||||");		if (windowServer == null)			return null;		try {			int count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				if (!StringUtil.blank(contig.getRead(i).getABIFile()) && !StringUtil.blank(contig.getRead(i).getABIFilePath()))					count++;			}			if (count == 0)				return null;			String[] fileNames = new String[count];			String[] paths = new String[count];			Read[] reads = new Read[count];			count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				String abiFile = contig.getRead(i).getABIFile();				String abiFilePath = contig.getRead(i).getABIFilePath();				reads[count] = contig.getRead(i);				if (!StringUtil.blank(abiFile) && !StringUtil.blank(abiFilePath)) {					fileNames[count] = abiFile;					paths[count] = abiFilePath;					count++;				}			}			if (paths==null  || fileNames==null)				return null;			Chromatogram[] chromatograms = new Chromatogram[paths.length];			Associable as = matrixData.getTaxaInfo(false);			String[] fileNamesTranslator = null;			String[] primerNamesTranslator = null;			String[] sampleCodesTranslator = null;			if (as != null) {				fileNamesTranslator = (String[])as.getAssociatedObject(NameReference.getNameReference("readFileNames"), taxon.getNumber());				primerNamesTranslator = (String[])as.getAssociatedObject(NameReference.getNameReference("primerForEachRead"), taxon.getNumber());				sampleCodesTranslator = (String[])as.getAssociatedObject(NameReference.getNameReference("sampleCodeForEachRead"), taxon.getNumber());			}			for (int i = 0; i<paths.length; i++){ //getting chromatograms from all of the reads				File file = new File(paths[i].toString(), fileNames[i].toString());				FileInputStream regIN = new FileInputStream(file);;				BufferedInputStream fileIN = new BufferedInputStream(regIN);				byte[] magicNumArray = new byte[4];				fileIN.read(magicNumArray);				ByteArrayInputStream magicIN = new ByteArrayInputStream(magicNumArray);				DataInputStream magicDIN = new DataInputStream(magicIN);				int magicNum = magicDIN.readInt();				magicIN.reset();				SequenceInputStream seqIN = new SequenceInputStream(magicIN,fileIN);//Debugg.println("fileName: " + fileNames[i].toString());				if (magicNum == ABIChromatogram.MagicNum) {					chromatograms[i] = new ABIChromatogram(seqIN,reads[i]);					}				else if (magicNum == SCFChromatogram.MagicNum) {					chromatograms[i] = new SCFChromatogram(seqIN, reads[i]);				}				else throw new IOException("Unknown file type");				if (chromatograms[i]!=null) {					String origName = findNameRefElement(fileNamesTranslator, fileNames[i]);					if (origName != null)						chromatograms[i].setTitle(origName.toString());					else						chromatograms[i].setTitle("Read " + (i+1));//					chromatograms[i].report("");					if (primerNamesTranslator!=null) {						String primerName = findNameRefElement(primerNamesTranslator, fileNames[i]);						reads[i].setPrimerName(primerName);   //DO NOT set this, as ther primer is now acquired later.					}					if (sampleCodesTranslator!=null) {						String sampleCodeSource = findNameRefElement(sampleCodesTranslator, fileNames[i], 1, 2);						String sampleCode = findNameRefElement(sampleCodesTranslator, fileNames[i], 2, 2);						reads[i].setSampleCode(sampleCode);   //DO NOT set this, as ther primer is now acquired later.						reads[i].setSampleCodeSource(sampleCodeSource);   //DO NOT set this, as ther primer is now acquired later.					}					if (reads[i].getComplemented())						chromatograms[i].reverseComplement(false);									}			}			if (existing == null){				ownerModule.hireAllEmployees(ChromInit.class);				VChromWindow cw = new VChromWindow(ownerModule, windowServer, table, matrixData, taxon,"Chromatograms: " + taxon.getName(), chromatograms, contig, reads); 				windowServer.setModuleWindow(cw);				if (!MesquiteThread.isScripting())					cw.setVisible(true);				windowServer.resetContainingMenuBar();				MesquiteModule.resetAllWindowsMenus();				return cw;			}			else {				existing.addContig(taxon, chromatograms, contig, reads);				return existing;			}		}		catch (MalformedURLException ex) {			System.out.println("Malformed URL");		}		catch (IOException ex) {			String exMessage = ex.getMessage();			String exName = ex.getClass().getName();			System.out.println("IO ERROR: " + exName + " : " + exMessage);		}		return null;	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	 to be self-titling so that when things change (names of files, tree lists, etc.)	 they can reset their titles properly*/	public void resetTitle(){		setTitle(title);	}	public Taxon getTaxon(){		return contigPanel.getTaxon();	}	public void centerPanelAtOverallPosition(int ic){		contigPanel.centerPanelsAtOverallPosition(ic);	}	public int getHomePositionInMatrix(){		return contigPanel.getHomePositionInMatrix();	}	public int getCenterBase(){		return contigPanel.getCenterBase();		}	public void synchChromToTable(boolean synchPosition){		contigPanel.synchChromToTable(synchPosition);	}	public int getConsensusPositionOfMatrixPosition(int ic){		return contigPanel.getConsensusPositionOfMatrixPosition(ic);	}	public  void scrollToMatrixBase(int ic){		contigPanel.scrollToMatrixBase(ic);	}	public  void scrollToOverallBase(int ic){		contigPanel.scrollToOverallBase(ic);	}	public  void scrollToConsensusBase(int ic){		contigPanel.scrollToConsensusBase(ic);	}	public SequencePanel getSequencePanel(int whichPanel){		return contigPanel.getSequencePanel(whichPanel);	}	public  int getTotalNumPeaks(){		return contigPanel.getTotalNumPeaks();	}	public  ContigDisplay getMainContigPanel(){		return contigPanel;	}	public void scrollsChanged(ContigPanel panel, int center){		if (panel != null && extraContigs != null && extraContigs.size()>0 && sequencesLocked.getValue()){			if (panel == contigPanel){				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff = p.getRelativeLockPos();					//if (p.isShownReversed() != contigPanel.isShownReversed())					//	diff = -diff;					/*(diff = c*f - c1*f1;					diffB = cB*f - c1B*f1;					c1B*f1 = cB*f - diff;					c1B = (cB*f - diff)/f1;					 */					int cB = center;					if (contigPanel.isShownReversed())						cB = -cB;					int c1B = cB-diff;					if (p.isShownReversed())						c1B = -c1B;					// 	Debugg.println("GET diff " + diff);									p.centerPanelsAtOverallPosition(c1B, false, true);					//	Debugg.println("GET diff after  contigPanel.getCenterBase()" + contigPanel.getCenterBase() + " p.getCenterBase() " + + p.getCenterBase() + " difference " + (contigPanel.getCenterBase()-p.getCenterBase()));									ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}			else {				int diff = panel.getRelativeLockPos();				/*diff = c*f - c1*f1;				diffB = cB*f - c1B*f1;				cB = (diff + c1B*f1)/f;				 */				int c1B = center;				if (panel.isShownReversed())					c1B = -c1B;				int cB = c1B+diff;				if (contigPanel.isShownReversed())					cB = -cB;				//if (panel.isShownReversed() != contigPanel.isShownReversed())				//	diff = -diff;				//Debugg.println("diffB " + diff);								contigPanel.centerPanelsAtOverallPosition(cB, false, true);				if (contigPanel.isShownReversed())					cB = -cB;				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff2 = p.getRelativeLockPos();					int c1B2 = cB-diff2;					if (p.isShownReversed())						c1B2 = -c1B2;					p.centerPanelsAtOverallPosition(c1B2, false, true);					ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}		}		else if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				ContigLinkerPanel link = p.getLinker();				link.repaint();			}		}	}	/*--------------------------------------*/	final int linkerHeight = 24;	/* Resize the chromatogram area and other components.*/	public void sizeDisplays(){		if (contigPanel != null){			int numContigs = extraContigs.size() + 1;			int left = 0;			if (numContigs>1 || showControls.getValue())				left = 24;			int modtest = 1;			if (extraContigs.size() % 2 == 0)				modtest = 0;			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				p.setBounds(left, getHeight()/numContigs*i, getWidth()-left, getHeight()/numContigs-linkerHeight);				p.sizePanels();				ContigControlPanel c = p.getControl();				if (i  % 2 == modtest)					c.setBackground(Color.lightGray);				else 					c.setBackground(ColorDistribution.veryLightGray);				c.setBounds(0, getHeight()/numContigs*i, left, getHeight()/numContigs);				ContigLinkerPanel link = p.getLinker();				link.setBounds(left, getHeight()/numContigs*(i+1)-linkerHeight, getWidth()-left, linkerHeight);			}			contigPanel.setBounds(left,getHeight()-getHeight()/numContigs, getWidth()-left, getHeight()/numContigs);			contigPanel.sizePanels();			if (numContigs>1 || showControls.getValue()){				ContigControlPanel c = contigPanel.getControl();				if (c == null){					c = new ContigControlPanel(contigPanel.getTaxon().getName(), contigPanel);					contigPanel.setControl(c);					c.setVisible(true);					addToWindow(c);				}				c.setBounds(0, getHeight()-getHeight()/numContigs, left, getHeight()/numContigs);				c.repaint();				//c.setBackground(ColorDistribution.lightGreen);				}		}	}	/* Resize the chromatogram area and other components.*/	public void dispose(){		super.dispose();		if (data != null)			data.removeListener(this);		if (originalData != null)			originalData.removeListener(this);		if (qualityData != null)			qualityData.removeListener(this);		if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				removeContig(p);				p.dispose();			}			extraContigs.removeAllElements();		}		if (contigPanel != null)			contigPanel.dispose();	}	/** passes which object changed, along with optional Notification object with details (e.g., code number (type of change) and integers (e.g. which character))*/	public void changed(Object caller, Object obj, Notification notification){		if (obj == data){			if (data.getTaxa().whichTaxonNumber(contigPanel.getTaxon())<0){				closeWindow();			}			else if (extraContigs != null)				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					if (data.getTaxa().whichTaxonNumber(p.getTaxon())<0)						removeContig(p);					p.dispose();				}					}	}	/** passes which object was disposed*/	public void disposing(Object obj){		if (obj == data || obj == qualityData)			closeWindow();	}	/** Asks whether it's ok to delete the object as far as the listener is concerned (e.g., is it in use?)*/	public boolean okToDispose(Object obj, int queryUser){		return true;	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setWindowSize(int w, int h){		super.setWindowSize(w,h);		sizeDisplays();	}	/*--------------------------------------*/	/* Called when the window has been resized, e.g. by user. <b>(overrides method of MesquiteWindow)</b>*/	public void windowResized(){		sizeDisplays();	}	protected ToolPalette makeToolPalette(){		MesquiteCommand sliderCommand = MesquiteModule.makeCommand("magnify", this);		ChromWindowPalette palette = new ChromWindowPalette(ownerModule, this, sliderCommand);		return palette;	}	public DNAData getMatrixData(){		return data;	}	public DNAData getOriginalData(){		return originalData;	}	public ContinuousData getQualityData(){		return qualityData;	}	public boolean showPrimers(){		return showPrimerMatches.getValue();	}	public Color getBackgroundColor(){		return backgroundColor;	}	public boolean getShowSinglePrimerMatch(){		return showSinglePrimerMatch.getValue();	}	public String getSinglePrimer(){		if (singlePrimer==null)			return "";		return singlePrimer.getValue();	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		Snapshot fromWindow = super.getSnapshot(file);		snapshot.incorporate(fromWindow,false);		snapshot.addLine("showControls  " + showControls.toOffOnString());		snapshot.addLine("toggleColorByQuality  " + colorByQuality.toOffOnString());		snapshot.addLine("toggleThickTrace  " + thickTrace.toOffOnString());		snapshot.addLine("toggleShowChromMatrixDisagreement  " + showReadMatrixConflict.toOffOnString());		snapshot.addLine("toggleShowReadReadConflict  " + showReadReadConflict.toOffOnString());		snapshot.addLine("toggleShowLowerQualSourceConflictsWithHigherQualRead  " + showLowerQualSourceConflictsWithHigherQualRead.toOffOnString());		snapshot.addLine("toggleFades  " + showFades.toOffOnString());		snapshot.addLine("toggleFadeLowQuality  " + fadeLowQuality.toOffOnString());		snapshot.addLine("toggleFadeNonSourceRead  " + fadeNonSourceRead.toOffOnString());		snapshot.addLine("toggleFadeNonSourceLowerQualityRead  " + fadeNonSourceLowerQualityRead.toOffOnString());		snapshot.addLine("toggleShowReadName  " + showReadName.toOffOnString());		snapshot.addLine("toggleDimLowQualityConflicts  " + dimLowQualityConflicts.toOffOnString());		snapshot.addLine("setFadeThreshold  " + fadeLowQualityThreshold.getValue());		snapshot.addLine("setJumpQualityThreshold  " + jumpQualityThreshold.getValue());		snapshot.addLine("setJumpConflictThreshold  " + jumpConflictThreshold.getValue());		snapshot.addLine("setDimConflictMarkerTheshold " + dimConflictMarkerThreshold.getValue());		snapshot.addLine("toggleShowA  " + showA.toOffOnString());		snapshot.addLine("toggleShowC " + showC.toOffOnString());		snapshot.addLine("toggleShowG " + showG.toOffOnString());		snapshot.addLine("toggleShowT " + showT.toOffOnString());		snapshot.addLine("toggleViewChromatograms  " + viewChromatograms.toOffOnString());		snapshot.addLine("toggleViewOverview  " + viewOverview.toOffOnString());		snapshot.addLine("toggleScrollToTouched " + scrollToTouched.toOffOnString());		snapshot.addLine("toggleShowBaseSource " + showBaseSource.toOffOnString());		snapshot.addLine("toggleShowCodonPosition " + showCodonPosition.toOffOnString());		snapshot.addLine("toggleJumpToNextBase " + jumpToNextBase.toOffOnString());		snapshot.addLine("toggleJumpToNextConflict " + jumpToNextReadReadConflict.toOffOnString());		snapshot.addLine("toggleJumpToNextReadMatrixConflict " + jumpToNextReadMatrixConflict.toOffOnString());		snapshot.addLine("toggleJumpToNextLowQuality " + jumpToNextLowQuality.toOffOnString());		snapshot.addLine("toggleJumpToNextAmbiguity " + jumpToNextAmbiguity.toOffOnString());		snapshot.addLine("toggleJumpToNextBadSource " + jumpToNextBadSourceRead.toOffOnString());		snapshot.addLine("showPrimerMatches " + showPrimerMatches.toOffOnString());		snapshot.addLine("showSinglePrimerMatch " + showSinglePrimerMatch.toOffOnString());		snapshot.addLine("setSinglePrimer  " + ParseUtil.tokenize(singlePrimer.getValue()));		snapshot.addLine("lockSequences " + sequencesLocked.toOffOnString());			Snapshot s = contigPanel.getSnapshot(file);		if (s != null){			snapshot.addLine("getMainContigPanel");			snapshot.addLine("tell It");			snapshot.incorporate(s, true);			snapshot.addLine("endTell");		}		if (extraContigs.size() > 0){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				Taxon taxon = p.getTaxon();				if (taxon != null){					int it = taxon.getNumber();					snapshot.addLine("showExtraContig " + it);					Snapshot sE = p.getSnapshot(file);					if (sE != null){						snapshot.addLine("tell It");						snapshot.incorporate(sE, true);						snapshot.addLine("endTell");					}				}			}		}		snapshot.addLine("scrollToOverallBase " + contigPanel.getCenterBase());		return snapshot;	}	/*.................................................................................................................*/	public void startPrimerShow(){		showPrimerMatches.setValue(true);		contigPanel.setUpPrimers();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setUpPrimers();		}	}	/*.................................................................................................................*/	public void redrawChromatPanels () {		contigPanel.repaintPanels();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.repaintPanels();		}	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Scrolls to overall base", "[base]", commandName, "scrollToOverallBase")) {				int it= MesquiteInteger.fromFirstToken(arguments, new MesquiteInteger(0));				if (MesquiteInteger.isCombinable(it))					scrollToOverallBase(it);		}		else if (checker.compare(this.getClass(), "Convert selected to gaps", null, commandName, "selectedToGaps")) {			contigPanel.selectedToGaps();		}		else if (checker.compare(this.getClass(), "Revert selected to called", null, commandName, "selectedToCalled")) {			contigPanel.selectedToRevert();		}		else if (checker.compare(this.getClass(), "Sets whether shading multiple sequences are locked", "[on; off]", commandName, "lockSequences")) {			sequencesLocked.toggleValue(new Parser().getFirstToken(arguments));			setSequencesLocked(sequencesLocked.getValue());		}		else if (checker.compare(this.getClass(), "Shows whether primer shown is the single specified primer", "[on; off]", commandName, "showSinglePrimerMatch")) {			showSinglePrimerMatch.toggleValue(new Parser().getFirstToken(arguments));			if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){				mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;				mod.setShowSinglePrimerMatch(showSinglePrimerMatch.getValue());			}			if (showPrimerMatches.getValue()) {				startPrimerShow();				 if (!MesquiteThread.isScripting())					redrawChromatPanels();			}		}		else if (checker.compare(this.getClass(), "Sets the single primer", "[primer name]", commandName, "setSInglePrimer")) {			String primerName =  new Parser().getFirstToken(arguments);			boolean success = true;			if (StringUtil.blank(primerName) && !MesquiteThread.isScripting()) {				if (singlePrimer==null)					singlePrimer = new MesquiteString("");				success = QueryDialogs.queryShortString(viewModule.containerOfModule(),"Primer Name", "Name of primer to display", singlePrimer);			}			else				singlePrimer.setValue(new Parser().getFirstToken(arguments));			if (success) {				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setSinglePrimer(singlePrimer.getValue());				}				if (showPrimerMatches.getValue())					startPrimerShow();			}		}		else if (checker.compare(this.getClass(), "Shows whether primers are shown matched", "[on; off]", commandName, "showPrimerMatches")) {			showPrimerMatches.toggleValue(new Parser().getFirstToken(arguments));			if (showPrimerMatches.getValue()){				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setShowPrimers(showPrimerMatches.getValue());				}				startPrimerShow();			}			else if (!MesquiteThread.isScripting())				redrawChromatPanels();		}		else if (checker.compare(this.getClass(), "Set Primer Sequence File...", null, commandName, "setPrimerSequenceFile")) {			if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){				mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;				mod.resetPrimersFile();				if (showPrimerMatches.getValue()){					contigPanel.setUpPrimers();					for (int i = 0; i< extraContigs.size(); i++){						ContigPanel p = (ContigPanel)extraContigs.elementAt(i);						p.setUpPrimers();					}				}			}		}		else if (checker.compare(this.getClass(), "Returns main contig panel", null, commandName, "getMainContigPanel")) {			return contigPanel;		}		else if (checker.compare(this.getClass(), "Shows extra contig (taxon, sequence)", "[number of taxon]", commandName, "showExtraContig")) {			if (data != null){				Taxon taxon = null;				MesquiteInteger pos = new MesquiteInteger(0);				int it= MesquiteInteger.fromFirstToken(arguments, pos);				if (!MesquiteInteger.isCombinable(it)){					if (MesquiteThread.isScripting())						return null;					taxon = data.getTaxa().userChooseTaxon(this, "Choose extra sequence to show");					if (taxon == null)						return null;					it = data.getTaxa().whichTaxonNumber(taxon);				}				else taxon = data.getTaxa().getTaxon(it);				NameReference aceRef = NameReference.getNameReference(AceFile.ACENAMEREF);				Associable tInfo = data.getTaxaInfo(false);				String path = null;				if (tInfo == null)					return null;				path = (String)tInfo.getAssociatedObject(aceRef, it);				if (StringUtil.blank(path))					return null;				path = MesquiteFile.composePath(ownerModule.getProject().getHomeFile().getDirectoryName(), path);				if (!MesquiteFile.fileExists(path))					return null;				long whichContig = tInfo.getAssociatedLong(AceFile.WHICHCONTIGREF, it);				AceFile ace = new AceFile(path, path, null, ownerModule,  true, 0.5);				this.table = (CMTable)table;				this.data = (DNAData)data;				if (whichContig < 0 || whichContig >= ace.getNumContigs())					return null;				VChromWindow.showChromatogram(ace.getContig((int)whichContig), table, data,  taxon, this, windowServer, ownerModule);				return extraContigs.elementAt(extraContigs.size()-1);			}		}		else if (checker.compare(this.getClass(), "Magnify chromatograms", null, commandName, "magnify")) {			MesquiteInteger io = new MesquiteInteger(0);			double x= MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				contigPanel.setMagnification(3.0 - x/2);				/*(3 - x/2)				 0 -- 3.0				 1-- 2.5				 2 --  2				 3 -- 1.5				 4-- 1.0				 5-- 0.5*/			}		}		else if (checker.compare(this.getClass(), "Sets the threshold below which low quality bases will be faded", "[fadeLowQualityThreshold]", commandName, "setFadeThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Fading Threshold", "Threshold for fading low quality bases:", fadeLowQualityThreshold.getValue(), 0, 100);			if (newNum>0  && newNum!=fadeLowQualityThreshold.getValue()) {				fadeLowQualityThreshold.setValue(newNum);				setFadeQualityThreshold(fadeLowQualityThreshold.getValue());				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between low quality bases", "[jumpQualityThreshold]", commandName, "setJumpQualityThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Option or Alt key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";			help += " sequence of quality less than the jump quality threshold value.  The jump quality threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Quality Threshold", "Jump between bases with quality less than:", help, jumpQualityThreshold.getValue(), 0, 100);			if (newNum>0  && newNum!=jumpQualityThreshold.getValue()) {				jumpQualityThreshold.setValue(newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between bases with conflicting reads", "[jumpConflictThreshold]", commandName, "setJumpConflictThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Control key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";			help += " sequence in which two reads, both of quality greater than or equal to the jump conflict threshold value, differ in their calls.  The jump conflict threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Conflict Threshold", "Jump between bases with conflict quality greater than:", help, jumpConflictThreshold.getValue(), 0, 100);			if (newNum>0  && newNum!=jumpConflictThreshold.getValue()) {				jumpConflictThreshold.setValue(newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold below conflcits will be dimmed", "[dimConflictMarkerThreshold]", commandName, "setDimConflictMarkerTheshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Dimming Threshold", "Quality threshold for dimming conflicts:", dimConflictMarkerThreshold.getValue(), 0, 100);			if (newNum>0  && newNum!=dimConflictMarkerThreshold.getValue()) {				dimConflictMarkerThreshold.setValue(newNum);				setDimConflictMarkerThreshold(dimConflictMarkerThreshold.getValue());				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets whether control bar is shown", "[on; off]", commandName, "showControls")) {			showControls.toggleValue(new Parser().getFirstToken(arguments));			sizeDisplays();		}		else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorByQuality")) {			colorByQuality.toggleValue(new Parser().getFirstToken(arguments));			setColorByQuality(colorByQuality.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the trace is shown using thick lines", "[on; off]", commandName, "toggleThickTrace")) {			thickTrace.toggleValue(new Parser().getFirstToken(arguments));			setThickTrace(thickTrace.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of low quality", "[on; off]", commandName, "toggleFadeLowQuality")) {			fadeLowQuality.toggleValue(new Parser().getFirstToken(arguments));			setFadeLowQuality(fadeLowQuality.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether any fades are shown", "[on; off]", commandName, "toggleFades")) {			showFades.toggleValue(new Parser().getFirstToken(arguments));			setShowFades(showFades.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source", "[on; off]", commandName, "toggleFadeNonSourceRead")) {			fadeNonSourceRead.toggleValue(new Parser().getFirstToken(arguments));			setFadeNonSourceRead(fadeNonSourceRead.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source AND of lower quality than the source", "[on; off]", commandName, "toggleFadeNonSourceLowerQualityRead")) {			fadeNonSourceLowerQualityRead.toggleValue(new Parser().getFirstToken(arguments));			setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether shading indicates whether a chromatogram's call is different from matrix state", "[on; off]", commandName, "toggleShowChromMatrixDisagreement")) {			showReadMatrixConflict.toggleValue(new Parser().getFirstToken(arguments));			setShowReadMatrixConflict(showReadMatrixConflict.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bar indicates whether there are differences among the Phred calls for each read.", "[on; off]", commandName, "toggleShowReadReadConflict")) {			showReadReadConflict.toggleValue(new Parser().getFirstToken(arguments));			setShowReadReadConflict(showReadReadConflict.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether to draw a box around the Phred calls for which the a lower quality read is the source and this conflicts with a higher quality read.", "[on; off]", commandName, "toggleShowLowerQualSourceConflictsWithHigherQualRead")) {			showLowerQualSourceConflictsWithHigherQualRead.toggleValue(new Parser().getFirstToken(arguments));			setShowLowerQualSourceConflictsWithHigherQualRead(showLowerQualSourceConflictsWithHigherQualRead.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the name of the read is shown", "[on; off]", commandName, "toggleShowReadName")) {			showReadName.toggleValue(new Parser().getFirstToken(arguments));			setShowReadName(showReadName.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the red boxes for low quality conflicts are dimmed below the bases in the Phred.Phrap.Mesquite listing", "[on; off]", commandName, "toggleDimLowQualityConflicts")) {			dimLowQualityConflicts.toggleValue(new Parser().getFirstToken(arguments));			setDimLowQualityConflicts(dimLowQualityConflicts.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the view is the overview", "[on; off]", commandName, "toggleViewOverview")) {			viewOverview.toggleValue(new Parser().getFirstToken(arguments));			if (viewOverview.getValue())				viewChromatograms.setValue(false);			contigPanel.switchView();			//repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the view is the chromatogram view", "[on; off]", commandName, "toggleViewChromatograms")) {			viewChromatograms.toggleValue(new Parser().getFirstToken(arguments));			if (viewChromatograms.getValue())				viewOverview.setValue(false);			contigPanel.switchView();			repaintAll();		}		//=======================================		else if (checker.compare(this.getClass(), "Sets whether the A trace is shown", "[on; off]", commandName, "toggleShowA")) {			showA.toggleValue(new Parser().getFirstToken(arguments));			setShowA(showA.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the C trace is shown", "[on; off]", commandName, "toggleShowC")) {			showC.toggleValue(new Parser().getFirstToken(arguments));			setShowC(showC.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the G trace is shown", "[on; off]", commandName, "toggleShowG")) {			showG.toggleValue(new Parser().getFirstToken(arguments));			setShowG(showG.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the T trace is shown", "[on; off]", commandName, "toggleShowT")) {			showT.toggleValue(new Parser().getFirstToken(arguments));			setShowT(showT.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether touching on the chromatograms centers the view to that base", "[on; off]", commandName, "toggleScrollToTouched")) {			scrollToTouched.toggleValue(new Parser().getFirstToken(arguments));			setScrollToTouched(scrollToTouched.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the source of the base (that is, the read Phrap chose as the primary one fro that base) is marked by a brown bar", "[on; off]", commandName, "toggleShowBaseSource")) {			showBaseSource.toggleValue(new Parser().getFirstToken(arguments));			setShowBaseSource(showBaseSource.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the codon position of a base is indicated by color", "[on; off]", commandName, "toggleShowCodonPosition")) {			showCodonPosition.toggleValue(new Parser().getFirstToken(arguments));			setShowCodonPosition(showCodonPosition.getValue());			repaintAll();		}//		=======================================		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next problem base", "[on; off]", commandName, "toggleJumpToNextBadSource")) {			jumpToNextBadSourceRead.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextBadSourceRead.getValue()) {				jumpToNextBase.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next base", "[on; off]", commandName, "toggleJumpToNextBase")) {			jumpToNextBase.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextBase.getValue()) {				jumpToNextReadReadConflict.setValue(false);				jumpToNextLowQuality.setValue(false);				jumpToNextReadMatrixConflict.setValue(false);				jumpToNextAmbiguity.setValue(false);				jumpToNextBadSourceRead.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next low quality base", "[on; off]", commandName, "toggleJumpToNextLowQuality")) {			jumpToNextLowQuality.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextLowQuality.getValue()) {				jumpToNextBase.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-read conflict", "[on; off]", commandName, "toggleJumpToNextConflict")) {			jumpToNextReadReadConflict.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextReadReadConflict.getValue()) {				jumpToNextBase.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-matrix conflict", "[on; off]", commandName, "toggleJumpToNextReadMatrixConflict")) {			jumpToNextReadMatrixConflict.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextReadMatrixConflict.getValue()) {				jumpToNextBase.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next matrix value with an IUPAC ambiguity code", "[on; off]", commandName, "toggleJumpToNextAmbiguity")) {			jumpToNextAmbiguity.toggleValue(new Parser().getFirstToken(arguments));			if (jumpToNextAmbiguity.getValue()) {				jumpToNextBase.setValue(false);			}		}		else if (checker.compare(this.getClass(), "Shows the matrix", null, commandName, "showMatrix")) {			MesquiteWindow f = ownerModule.getEmployer().containerOfModule();			if (f!= null)				f.show();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	private void setShowA(boolean show){		contigPanel.setShowA(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowA(show);		}	}	private void setShowC(boolean show){		contigPanel.setShowC(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowC(show);		}	}	private void setShowG(boolean show){		contigPanel.setShowG(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowG(show);		}	}	private void setShowT(boolean show){		contigPanel.setShowT(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowT(show);		}	}	public void setScrollToTouched(boolean s){		contigPanel.setScrollToTouched(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setScrollToTouched(s);		}	}	public void setShowBaseSource(boolean s){		contigPanel.setShowBaseSource(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseSource(s);		}	}	public void setShowCodonPosition(boolean s){		contigPanel.setShowCodonPosition(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowCodonPosition(s);		}	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		contigPanel.setShowReadName(showReadName);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadName(showReadName);		}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		contigPanel.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		contigPanel.setShowReadMatrixConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadMatrixConflict(show);		}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		contigPanel.setShowReadReadConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadReadConflict(show);		}	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		contigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowLowerQualSourceConflictsWithHigherQualRead(show);		}	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		contigPanel.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		contigPanel.setDimLowQualityConflicts(dimLowQualityConflicts);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimLowQualityConflicts(dimLowQualityConflicts);		}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		contigPanel.setFadeLowQuality(fadeLowQuality);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeLowQuality(fadeLowQuality);		}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		contigPanel.setShowFades(showFades);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowFades(showFades);		}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		contigPanel.setFadeNonSourceRead(fadeNonSourceRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceRead(fadeNonSourceRead);		}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		contigPanel.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		contigPanel.setFadeQualityThreshold(fadeQualityThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeQualityThreshold(fadeQualityThreshold);		}	}	/*.................................................................................................................*/	public void setSequencesLocked(boolean seqLocked) {		contigPanel.setSequencesLocked(seqLocked);		int centerMain = contigPanel.getCenterBase();		if (contigPanel.isShownReversed())			centerMain = -centerMain;		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setSequencesLocked(seqLocked);			int centerThis = p.getCenterBase();			if (p.isShownReversed())				centerThis = -centerThis;			int diff = centerMain - centerThis;			//	Debugg.println("SET diff " + diff);			p.setRelativeLockPos(diff);		}	}	/*.................................................................................................................*/	public void setColorByQuality(boolean cbQ) {		contigPanel.setColorByQuality(cbQ);	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		contigPanel.setThickTrace(thickTrace);	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*2+1<namesTranslator.length; i++){			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*2]))				return namesTranslator[i*2+1];		}		return changedName;	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName, int whichElement, int numElements){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*(numElements+1)+whichElement<namesTranslator.length; i++){   //DavidJan07: OK?			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*(numElements+1)]))				return namesTranslator[i*(numElements+1)+whichElement];		}		return changedName;	}	}//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^class ContigPanel extends MesquitePanel implements ContigDisplay, AdjustmentListener {	int minimumChromatoHeight=0;	double horizScale = 1.0;	double peakDistance = 20.0;	int centerBase = 0;	MatrixSequence originalSequence;	MatrixSequence editedSequence;	ChromatogramPanel[] chromPanels;	Chromatogram[] chromatograms;	SequencePanel aceContigPanel;	SequencePanel matrixSeqPanel;	OrigImportedSeqPanel origSeqPanel;	Contig contig;	Taxon taxon;	String sequenceID = null;	int seqPanelHeight = 36;	int scrollDepth = 16;	int bufferHeight = 4;	Panel bufferPanel;	int numSequencePanels = 3;	int spacer = 4;	ContigControlPanel control;	ContigLinkerPanel linker;	Scrollbar hbar;	MesquitePanel scrollPanel;	VChromWindow window;	DNAData data;	DNAData originalData;	ContinuousData qualityData;	MesquiteTable table;	MesquiteBoolean showComplemented = new MesquiteBoolean(false);	MesquiteBoolean showReversed = new MesquiteBoolean(false);	boolean isPrimary = false;	boolean locked = false;	static int numIDs = 0;	int id;	public ContigPanel (VChromWindow window, DNAData data, DNAData originalData, ContinuousData qualityData, MesquiteTable table, Taxon taxon, Chromatogram[] chroms, Contig contig, boolean isPrimary){		//^^^^single contig^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		this.taxon = taxon;		id = ++numIDs;		this.contig = contig;		this.isPrimary = isPrimary;		chromatograms = chroms;		double totalPeakDistance = 0.0;		this.data = data;		this.originalData = originalData;		this.qualityData = qualityData;		this.window = window;		this.table = table;		addKeyListener(this);		if (chroms != null){			chromPanels = new ChromatogramPanel[chroms.length];			chromVis = new boolean[chroms.length];			for (int i=0; i<chroms.length; i++){				chromVis[i] = true;				chromPanels[i] = new ChromatogramPanel(chroms[i], this, i, id);				chromPanels[i].setVisible(true);				//	chromPanels[i].setBackground(Color.blue);				//addToWindow(chromPanels[i]);				add(chromPanels[i]);				totalPeakDistance+= chroms[i].getAveragePeakDistance();			}			peakDistance = totalPeakDistance/chroms.length;			}		aceContigPanel = new MainConsensusPanel(this, contig, id);		aceContigPanel.setVisible(true);		aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(true);		add(aceContigPanel);		if (originalData != null){			originalSequence =new OrigSequenceImported((MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData, contig, taxon.getNumber());			origSeqPanel = new OrigImportedSeqPanel(this, originalSequence, id);			origSeqPanel.setVisible(true);			add(origSeqPanel);		}		editedSequence =new EditedMatrixSequence((MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData,  contig, taxon.getNumber());		matrixSeqPanel = new MatrixSequencePanel(this, editedSequence, id);		if (originalSequence == null)			originalSequence = editedSequence;		matrixSeqPanel.setVisible(true);		add(matrixSeqPanel);		bufferPanel = new Panel();		//bufferPanel.setBackground(Color.green);		bufferPanel.setVisible(true);		add(bufferPanel);		int numPeaksVisible = getApproximateNumberOfPeaksVisible();		centerBase = numPeaksVisible/2;		scrollPanel = new MesquitePanel();		hbar = new Scrollbar(Scrollbar.HORIZONTAL);		hbar.addAdjustmentListener(this);		hbar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumPeaks() + numPeaksVisible/2); //		Debugg.println("centerBase: " +centerBase + ", numPeaksVisible: " + numPeaksVisible + ", totalPeaks: " + getTotalNumPeaks());		hbar.setUnitIncrement(1);		hbar.setBlockIncrement(1);//		hbar.addKeyListener(this);		scrollPanel.add("South",hbar);		//hbar.setVisible(true);		scrollPanel.setVisible(true);		scrollPanel.setBackground(Color.red);		add(scrollPanel);		Associable tInfo = data.getTaxaInfo(false);		trimOffset = 0;		if (tInfo != null && taxon != null) {			int it = taxon.getNumber();			long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);			if (MesquiteLong.isCombinable(t)) {				trimOffset = (int)t;				int padBeforeTrim = contig.resetPadding(trimOffset, false);				trimOffset -= padBeforeTrim;			}		}		synchChromToTable(true);		hbar.addKeyListener(this);	}	public int getID(){		return id;	}	public void setUpPrimers(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].setUpPrimers();			if (!MesquiteThread.isScripting())				chromPanels[i].repaintPanel();		}	}	public String[][] getPrimerSequences(){		MesquiteModule m = window.viewModule;		if (m instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){			mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)m;			return mod.getPrimerSequences();		}		return null;	}	public boolean showPrimers(){		return window.showPrimers();	}	public boolean getShowSinglePrimerMatch(){		return window.getShowSinglePrimerMatch();	}	public String getSinglePrimer(){		return window.getSinglePrimer();	}	public void setSequencesLocked(boolean seqLocked) {		locked = seqLocked;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		snapshot.addLine("showReversed " + showReversed.toOffOnString());		snapshot.addLine("showComplemented " + showComplemented.toOffOnString());		snapshot.addLine("setRelativeLockPos " + relativeLockPos);		return snapshot;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Shows sequence as reversed", "[]", commandName, "showReversed")) {			showReversed.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.reverseButton.setOptionDown(showReversed.getValue());		}		else if (checker.compare(this.getClass(), "Shows sequence as complemented", "[]", commandName, "showComplemented")) {			showComplemented.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.complementButton.setOptionDown(showComplemented.getValue());		}		else if (checker.compare(this.getClass(), "Toggles a chromatogram is visible ", "[number of chromatogram]", commandName, "toggleChromatVisible")) {			int which = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(which) && which < chromVis.length && which >=0)				setChromatVisible(which, !chromVis[which]);			//sizePanels();			control.resize();			control.repaint();		}		else if (checker.compare(this.getClass(), "Sets the relative lock position ", "[difference]", commandName, "setRelativeLockPos")) {			int pos = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(pos))				setRelativeLockPos(pos);		}		else if (checker.compare(this.getClass(), "Closes extra panel", "[]", commandName, "goAway")) {			window.removeContig(this);		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public void dispose(){		if (originalSequence!=null)			originalSequence.dispose();		if (editedSequence != null)			editedSequence.dispose();		super.dispose();	}	int relativeLockPos;	public int getRelativeLockPos(){		return relativeLockPos;	}	public void setRelativeLockPos(int p){		relativeLockPos = p;	}	public void setControl(ContigControlPanel c){		this.control = c;	}	public ContigControlPanel getControl(){		return control;	}	public void setLinker(ContigLinkerPanel c){		this.linker = c;	}	public ContigLinkerPanel getLinker(){		return linker;	}	public void setExplanation(String s){		window.setExplanation(s);	}	/*--------------------*/	public int getNumChromats(){		return chromPanels.length;	}	public int getChromatTop(int i){		if (i>=0 && i<chromPanels.length)			return chromPanels[i].getBounds().y;		return 0;	}	public void setChromatVisible(int i, boolean v){		if (i>=0 && i<chromVis.length){			boolean ch = v != chromVis[i];			chromVis[i] = v;			control.resetButtons();			if (ch)				sizePanels();		}	}	public boolean getChromatVisible(int i){		if (i>=0 && i<chromVis.length)			return chromVis[i];		return false;	}	public int getNumChromatVisible(){		int count = 0;		for (int i=0; i<chromVis.length; i++)			if (chromVis[i])				count++;		return count;	}	boolean[] chromVis;	final int closedHeight = 24;	/*--------------------------------------*/	/* Resize the chromatogram area and other components.*/	public void sizePanels(){		//TODO: size panels		if (scrollPanel!=null)			scrollPanel.setVisible(false);		int border = 2;		int totalWidth = getWidth();//		int totalHeight = getHeight();		if (chromPanels==null)			return;		int chromatoHeight = 0;		if (getNumChromatVisible()>0)			chromatoHeight = MesquiteInteger.maximum(minimumChromatoHeight,(getChromAreaHeight()-(chromPanels.length-getNumChromatVisible())*closedHeight)/getNumChromatVisible()) ;		int top = 0;		for (int i=0; i<chromPanels.length; i++){			int thisHeight = 0;			if (chromVis[i])				thisHeight = chromatoHeight;			else				thisHeight = closedHeight; 			chromPanels[i].setBounds(border,top, totalWidth-border*2, thisHeight -spacer);			top += thisHeight;			// chromPanels[i].setVisible((i+2)*chromatoHeight<getChromAreaHeight()+spacer+1 || i==0);		}		bufferPanel.setBounds(border,getChromAreaHeight(),totalWidth-border*2,bufferHeight);		aceContigPanel.setBounds(border,getChromAreaHeight()+ bufferHeight,totalWidth-border*2 ,seqPanelHeight);		if (origSeqPanel!=null)			origSeqPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight + bufferHeight,totalWidth-border*2,seqPanelHeight);		matrixSeqPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight*2 + bufferHeight,totalWidth-border*2,seqPanelHeight);		if (scrollPanel!=null) {			scrollPanel.setBounds(border,getChromAreaHeight()+seqPanelHeight*numSequencePanels + bufferHeight,totalWidth-border*2,scrollDepth);			hbar.setBounds(0,0,totalWidth-border*2,scrollDepth);			scrollPanel.setVisible(true);		}		if (hbar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			hbar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumPeaks() + numPeaksVisible/2);// - numPeaksVisible -1);			int blockIncrement = numPeaksVisible/2-1;			if (blockIncrement<1)				blockIncrement=1;			hbar.setBlockIncrement(blockIncrement);		}	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setSize(int w, int h){		super.setSize(w,h);		sizePanels();		if (hbar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			hbar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumPeaks() + numPeaksVisible/2);// - numPeaksVisible -1);			hbar.setBlockIncrement(numPeaksVisible);		}	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return window.colorByQuality.getValue();	}	/*.................................................................................................................*/	public Color getBaseColor(char c, Color backgroundColor) {		switch (c) {		case 'A':			return getBaseColor(DNAState.A, backgroundColor);		case 'C':			return getBaseColor(DNAState.C, backgroundColor);		case 'G':			return getBaseColor(DNAState.G, backgroundColor);		case 'T':			return getBaseColor(DNAState.T, backgroundColor);		case 'a':			return getBaseColor(DNAState.A, backgroundColor);		case 'c':			return getBaseColor(DNAState.C, backgroundColor);		case 'g':			return getBaseColor(DNAState.G, backgroundColor);		case 't':			return getBaseColor(DNAState.T, backgroundColor);		case '-':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case '*':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case 'N':			return getBaseColor(DNAState.unassigned, backgroundColor);		case '?':			return getBaseColor(DNAState.unassigned, backgroundColor);		default:			return Color.darkGray;		}	}	/*.................................................................................................................*/	public Color getBaseColor(long c, Color backgroundColor) {		Color color = Color.darkGray;		if (c == DNAState.unassigned)			color = Color.darkGray;		else if (c == DNAState.inapplicable)			color =  Color.gray;		c = c & DNAState.statesBitsMask;		if (c == DNAState.A) //should make this more efficient by using constants!			color =  window.AColor;		else if (c == DNAState.C)			color =  window.CColor;		else if (c == DNAState.G)			color =  window.GColor;		else if (c == DNAState.T)			color =  window.TColor;		else if (c == (DNAState.A | DNAState.C | DNAState.G | DNAState.T)  )			color =  Color.darkGray;		if (backgroundColor.equals(color) && color.equals(Color.black))			color= Color.white;		return color;			}		/*.................................................................................................................*/	public Color getBackgroundColor() {		return window.getBackgroundColor();	}	public int getCenterBase(){		return centerBase;	}	public boolean isShownReversed(){		return showReversed.getValue();	}	public boolean isShownComplemented(){		return showComplemented.getValue();	}	//for coordinating selection	int firstTouched = MesquiteInteger.unassigned;	int secondTouched = MesquiteInteger.unassigned;	public void setFirstTouchedOverall(int ic){		firstTouched = ic;	}	public int getFirstTouchedOverall(){		return firstTouched;	}	public int getFirstTouchedConsensus(){		if (!MesquiteInteger.isCombinable(firstTouched))			return firstTouched;		int c =  getConsensusBaseFromOverallBase(firstTouched);		if (c <0)			return 0;		return c;	}	public void setSecondTouchedOverall(int ic){		secondTouched = ic;	}	public int getSecondTouchedOverall(){		return secondTouched;	}	public int getSecondTouchedConsensus(){		if (!MesquiteInteger.isCombinable(secondTouched))			return secondTouched;		int c =  getConsensusBaseFromOverallBase(secondTouched);		if (c <0)			return 0;		return c;	}	void setShowA(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowA(show);	}	void setShowC(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowC(show);	}	void setShowG(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowG(show);	}	void setShowT(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowT(show);	}	public void setScrollToTouched(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setScrollToTouched(s);	}	public void setShowBaseSource(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowBaseSource(s);	}	public void setShowCodonPosition(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowCodonPosition(s);	}	/*...............................................................................................................*/	public String getContigDisplayExplanation (int consensusBase){		StringBuffer sb = new StringBuffer();		sb.append("Consensus Base Quality: " + contig.getQualityOfBase(consensusBase));		if (window.showReadReadConflict.getValue())			sb.append("\nRed/pink bar: two reads conflict. ");		if (window.showLowerQualSourceConflictsWithHigherQualRead.getValue())			sb.append("Box: source read is notably lower quality than other read. ");		return sb.toString();	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadName(showReadName);			}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowBaseNumberWithinRead(showBaseNumberWithinRead);			}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadMatrixConflict(show);			}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowReadReadConflict(show);	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		if (contig!=null)			contig.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimConflictMarkerThreshold(dimConflictMarkerThreshold);			}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		if (contig!=null)			contig.setDimLowQualityConflicts(dimLowQualityConflicts);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimLowQualityConflicts(dimLowQualityConflicts);			}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowFades(showFades);			}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeLowQuality(fadeLowQuality);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceRead(fadeNonSourceRead);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);			}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeQualityThreshold(fadeQualityThreshold);			}	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setThickTrace(thickTrace);			}	}	/*.................................................................................................................*/	public void setColorByQuality(boolean cbQ) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setColorByQuality(cbQ);			}		if (aceContigPanel!=null)			aceContigPanel.setColorByQuality(cbQ);		if (matrixSeqPanel!=null)			matrixSeqPanel.setColorByQuality(cbQ);		if (origSeqPanel!=null)			origSeqPanel.setColorByQuality(cbQ);	}	/*.................................................................................................................*/	public double getHorizScale() {		return horizScale;	}	/*.................................................................................................................*/	public double getAveragePeakDistance() {		return (peakDistance * getHorizScale());	}	/*.................................................................................................................*/	public int getApproximateNumberOfPeaksVisible() {		if (getAveragePeakDistance()<=0)			return 0;		else			return (int)(getBounds().width/getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the number of pixels the window is scrolled */	public int getCenterPixelFromCenterBase(int centerBase){		return (int)((centerBase)*getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the base number within the consensus sequence at the base baseNumber (which is numbered from the beginning, including excess bases at the start).   */	public int getConsensusBaseFromOverallBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return baseNumber-contig.getReadExcessAtStart();	}	/*.................................................................................................................*/	public int getOverallBaseFromConsensusBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return baseNumber+contig.getReadExcessAtStart();	}	/*.................................................................................................................*/	public int getTotalNumPeaks() {		int numPeaks = contig.getNumBases() + contig.getReadExcessAtStart()+ contig.getReadExcessAtEnd();//		Debugg.println("|||| totalNumPeaks: " + numPeaks + ", numBases: " + contig.getNumBases()+ ", excessAtStart: " + contig.getReadExcessAtStart()+ ", excessAtEnd: " + contig.getReadExcessAtEnd());		return numPeaks;	}	/*.................................................................................................................*/	public Contig getContig() {		return contig;	}	/*.................................................................................................................*/	public int getHorizontalPixels(int pixels) {		return (int)(pixels * getHorizScale());	}	void setMagnification(double mag){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setMagnification(mag);		}	}	/*--------------------------------------*/	public int getChromAreaHeight(){		int totalHeight = getHeight();		return totalHeight-scrollDepth - seqPanelHeight*numSequencePanels - bufferHeight;	}	public SequencePanel getSequencePanel(int whichPanel){		if (whichPanel == 0)			return aceContigPanel;		else if (whichPanel == 1)			return origSeqPanel;		else if (whichPanel == 2)			return matrixSeqPanel;		return null;	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at consensus base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtConsensusPosition(int ic){		centerPanelsAtOverallPosition(getOverallBaseFromConsensusBase(ic));	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtOverallPosition(int ic){		centerPanelsAtOverallPosition(ic, true, false);	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtOverallPosition(int ic, boolean notifyWindow, boolean adjustScroll){		if (adjustScroll)			hbar.setValue(ic);		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].centerPanelAtOverallPosition(ic);  		}		aceContigPanel.centerPanelAtOverallPosition(ic);		matrixSeqPanel.centerPanelAtOverallPosition(ic);		if (origSeqPanel!=null)			origSeqPanel.centerPanelAtOverallPosition(ic);		centerBase = ic;		if (notifyWindow)			window.scrollsChanged(this, ic);	}	public int getHomePositionInMatrix(){		return getMatrixPositionOfConsensusPosition(getConsensusBaseFromOverallBase(centerBase), originalData);	}	/*--------------------------------------*/	public void focusMatrixOn(int ic1, int ic2){  //ic1 is the first touched read base (NOT consensus base); ic2 is the last touched base		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		if (!MesquiteInteger.isCombinable(ic1) && !MesquiteInteger.isCombinable(ic2))  // they are both unassigned, bail			return;		else if (MesquiteInteger.isCombinable(ic1) && ic1<0 && ic2<0)  // they are both <0, and so we don't want to move the matrix here			return;		else if (!MesquiteInteger.isCombinable(ic2) || (ic2<0) ||  ic2 == ic1){   // ic2 hasn't been assigned, or ic1 and ic2 are both positive and assigned			table.setFocusedCell(getMatrixPositionOfConsensusPosition(ic1, originalData), it);		}		else {  //both are unassigned, and at least one is positive			table.setFocusedSequence(getMatrixPositionOfConsensusPosition(ic1, originalData), getMatrixPositionOfConsensusPosition(ic2, originalData), it);		}	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void synchChromToTable(boolean synchPosition){		if (!listen)			return;		if (!table.anyCellSelectedAnyWay())			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		for (int overallBase =0; overallBase<getTotalNumPeaks(); overallBase++) { 			int consensusBase = getConsensusBaseFromOverallBase(overallBase);			int mPos = getMatrixPositionOfConsensusPosition(consensusBase, originalData);			boolean sel = table.isCellSelectedAnyWay(mPos, it);			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = overallBase;				lastSel = overallBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}			changed = setSelectedConsensusPositionInChrom(consensusBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void matrixChanged(boolean synchPosition){		synchChromToTable(synchPosition);		repaintPanels();	}		/*--------------------------------------*/	public boolean getSelectedAnyChromatogram(int overallBase){		for (int i=0; i<chromPanels.length; i++){			if (chromPanels[i].getSelected(overallBase))				return true;		}		return false;	}	/*--------------------------------------*/	public void synchTableToChrom(boolean synchPosition){		if (!listen)			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		for (int overallBase =0; overallBase<getTotalNumPeaks(); overallBase++) { 			boolean sel = getSelectedAnyChromatogram(overallBase);			int consensusBase = getConsensusBaseFromOverallBase(overallBase);			int mPos = getMatrixPositionOfConsensusPosition(consensusBase, originalData); //Wayne: use this to then select table			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = overallBase;				lastSel = overallBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}			changed = setSelectedConsensusPositionInChrom(consensusBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	void selectedToGaps(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int ic = 0; ic< getTotalNumPeaks(); ic++){			if (getSelectedConsensusPositionInChrom(ic))				((DNAData)data).setState(getMatrixPositionOfConsensusPosition(ic, originalData), it, CategoricalState.inapplicable);		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void selectedToRevert(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int ic = 0; ic< getTotalNumPeaks(); ic++){			if (getSelectedConsensusPositionInChrom(ic)){				int icc = getMatrixPositionOfConsensusPosition(ic, originalData);				((DNAData)data).setState(icc, it, ((DNAData)originalData).getStateRaw(icc, it));			}		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfConsensusBase(int ic){		int basesFromLeftSide = ic+getContig().getReadExcessAtStart();   // now adjust for the fact that the consensus sequence may not start at 0, 		// as there may be excess on the left		return (int)(basesFromLeftSide*getAveragePeakDistance());	}	/*--------------------------------------*/	public long getMatrixStateLongAtConsensusPosition(int ic){		if (taxon == null)			return '-';		int icM = getMatrixPositionOfConsensusPosition(ic);		int it = taxon.getNumber();			return data.getState(icM, it);	}	/*--------------------------------------*/	public char getMatrixStateAtConsensusPosition(int ic){		if (taxon == null)			return '-';		int icM = getMatrixPositionOfConsensusPosition(ic);		int it = taxon.getNumber();			return DNAData.getIUPACChar(data.getState(icM, it));	}	/*--------------------------------------*/	/** This returns the number of padded bases before consensus site ic  */	public int getNumPaddedBeforeConsensusBase(int ic){		return getContig().getNumPaddedBefore(ic);	}	/*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedBeforeConsensusBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfConsensusPosition(ic-1);		int icmAfter = getMatrixPositionOfConsensusPosition(ic);		if (icmAfter-icmBefore <=1)			return 0;		if (taxon == null)			return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	/*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedAfterConsensusBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfConsensusPosition(ic);		int icmAfter = getMatrixPositionOfConsensusPosition(ic+1);		if (icmAfter-icmBefore <=1)			return 0;		if (taxon == null)			return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	public int getSpaceInsertedAfterConsensusBase(int ic){		int numInserted = getNumInsertedAfterConsensusBase(ic);		if (numInserted>0)			return (int)(getAveragePeakDistance()*numInserted);		return 0;	}	public int getSpaceInsertedBeforeConsensusBase(int ic){		int numInserted = getNumInsertedBeforeConsensusBase(ic);		if (numInserted>0)			return (int)(getAveragePeakDistance()*numInserted);		return 0;	}	public int getTotalSpaceInsertedBeforeConsensusBase(int ic){		int total = 0;		for (int i = 0; i<=ic; i++){			total+= getNumInsertedBeforeConsensusBase(i);		}		return (int)(total*getAveragePeakDistance());	}	private int getConsensusFromUnpadded(int ic){		return getContig().getPaddedSiteFromUnpaddedSite(ic);	}	/*--------------------------------------*/	/** This should return for overall site ic what codon position the site is. */	public int  getCodonPositionOfOverallBase(int overallBase){		if (data==null)			return 0;		int consensusBase = getConsensusBaseFromOverallBase(overallBase);		int matrixCharacter = getMatrixPositionOfConsensusPosition(consensusBase, data);		if (matrixCharacter>=0 && matrixCharacter<data.getNumChars())			return data.getCodonPosition(matrixCharacter);		else			return 0;	}	/*--------------------------------------*/	public int getMatrixPositionOfConsensusPosition(int consensusBase){		return getMatrixPositionOfConsensusPosition(consensusBase, originalData);	}	/** This should return for consensus site ic what character in matrix it corresponds to.  	 * This is needed in case the sequence has been aligned,	 * and thus is not left justified and contiguous.  It also accounts for the trimming that is done in going from 	 * the consensus (i.e., main contig) sequence to the sequence in the matrix. */	public int getMatrixPositionOfConsensusPosition(int consensusBase, DNAData data){		//	if (true)		/*		return getMatrixPositionOfPaddedConsensusPosition(consensusBase, data);		 if (trimOffset<0){		 Associable tInfo = data.getTaxaInfo(false);		 trimOffset = 0;		 if (tInfo != null && taxon != null) {		 int it = taxon.getNumber();		 long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);		 if (MesquiteLong.isCombinable(t)) {		 trimOffset = (int)t;		 }		 }		 }		 */		int sequencePosition = consensusBase - trimOffset - getNumPaddedBeforeConsensusBase(consensusBase);//		Debugg.println("sequencePosition consensusBase " + consensusBase + " trimOffset "  + trimOffset);		if (taxon != null)			return originalSequence.matrixBaseFromSequenceBase(sequencePosition);		return sequencePosition;	}	public int getConsensusPositionOfMatrixPosition(int ic){		return getConsensusPositionOfMatrixPosition(ic, originalData);	}	/*--------------------------------------*/	/*@@@@@@@@@This should return for character ic in matrix/table, what is the position in the consensus.  This is needed in case the sequence has been aligned,	 and thus is not left justified and contiguous.  This has access to both the data and table @@@@@@@@@@@*/	public int getConsensusPositionOfMatrixPosition(int ic, DNAData data){		//if (true)		//	return getPaddedConsensusPositionOfMatrixPosition(ic, data);		int sequencePosition = ic;		if (taxon != null){			sequencePosition = originalSequence.sequenceBaseFromMatrixBase(ic);		}		/*		 if (trimOffset<0){		 Associable tInfo = data.getTaxaInfo(false);		 trimOffset = 0;		 if (tInfo != null && taxon != null) {		 int it = taxon.getNumber();		 long t =	tInfo.getAssociatedLong(NameReference.getNameReference("startTrim"), it);		 if (MesquiteLong.isCombinable(t)) {		 trimOffset = (int)t;		 }		 }		 }		 */		return getConsensusFromUnpadded(sequencePosition + trimOffset); // + trimOffset;	}	/*--------------------------------------*/	int trimOffset = -1;	static boolean listen = true; //static because all windows need to stop listening momentarily	/*--------------------------------------*/	/*This uses indices as in consensus*/	public boolean getSelectedConsensusPositionInChrom(int ic){		return matrixSeqPanel.getSelectedConsensus(ic);	}	public boolean getSelectedOverallBase(int overallBase) {		return chromPanels[0].getSelected(overallBase);	}	/*This uses indices as in consensus*/	public boolean setSelectedConsensusPositionInChrom(int ic, boolean sel, boolean repnt){		if (!listen)			return false;		boolean changed = false;		for (int i=0; i<chromPanels.length; i++){			changed = chromPanels[i].selectConsensusPositionInChrom(ic, sel, repnt) || changed;		}		changed = aceContigPanel.setSelectedConsensus(ic, sel, repnt) || changed;		changed = matrixSeqPanel.setSelectedConsensus(ic, sel, repnt) || changed;		if (origSeqPanel!=null)			changed = origSeqPanel.setSelectedConsensus(ic, sel, repnt) || changed;		return changed;	}	/*--------------------------------------*/	//this is consensus position	public void selectConsensusPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int ic = getMatrixPositionOfConsensusPosition(i, originalData);			int it = taxon.getTaxa().whichTaxonNumber(taxon);//			originalSequence.dumpFirstPositions();			table.selectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	//this is consensus position	public void deselectConsensusPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			int ic = getMatrixPositionOfConsensusPosition(i, originalData);			table.deselectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	public void deselectAllInTable(){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			for (int ic = 0; ic<table.getNumColumns(); ic++){				table.deselectCell(ic, it);				table.redrawCell(ic, it);			}		}		listen = true;	}	public void deselectAllInPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}		aceContigPanel.deselectAll();		matrixSeqPanel.deselectAll();		if (origSeqPanel!=null)			origSeqPanel.deselectAll();	}	public void deselectAllChrom(int overallBase){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll(overallBase);		}	}	/*--------------------------------------*/	public void switchView(){		/*			 for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setVisible(viewChromatograms.getValue());			}			aceContigPanel.setVisible(viewChromatograms.getValue());			matrixSeqPanel.setVisible(viewChromatograms.getValue());			if (origSeqPanel!=null)				origSeqPanel.setVisible(viewChromatograms.getValue());		 */	}	/*--------------------------------------*/	public void repaintPanels(){		if (window.viewChromatograms.getValue()) {			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].repaintPanel();			}			aceContigPanel.repaintPanel();			matrixSeqPanel.repaintPanel();			if (origSeqPanel!=null)				origSeqPanel.repaintPanel();		} 		else if (window.viewOverview.getValue()) {		}	}	/*--------------------------------------*/	public Taxon getTaxon(){		return taxon;	}	int keys = 0;	public void keyReleased(KeyEvent e){	}	public void keyTyped(KeyEvent e){	}	public void keyPressed(KeyEvent e){		int k = e.getKeyCode();		if (k==KeyEvent.VK_LEFT) {			if (window.jumpToNextBase.getValue())				scrollToConsensusBaseOffset(-1);  //David: deselect any selection			else 				goToNextProblem(false, false);		}		else if (k==KeyEvent.VK_RIGHT) {			if (window.jumpToNextBase.getValue())				scrollToConsensusBaseOffset(1);  //David: deselect any selection			else 				goToNextProblem(true, false);		}	}	/*.................................................................................................................*/ 	private int nextLowQuality(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextAmbiguity(boolean right) {  // next ambiguity either in the matrix base or the original Phred.Phrap.Mesquite calls		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					long contigBase = getMatrixStateLongAtConsensusPosition(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}					contigBase = contig.getBase(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					long contigBase = getMatrixStateLongAtConsensusPosition(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}					contigBase = contig.getBase(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextSourceReadIsLowerQualityAndConflicts(boolean right, int smallConflictThreshold, int largeConflictThreshold, boolean strongly) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextSourceReadIsLowerQuality(boolean right, int smallConflictThreshold, int largeConflictThreshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts,largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadReadConflict(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextDoublePeak(boolean right, int threshold) {   //threshold is quality threshold		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		MesquiteDouble fraction = new MesquiteDouble(0.0);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);	Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {	Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());//	 highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);	Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {	Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());//	 highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadMatrixConflict(boolean right, int threshold) {		int centerConsensusBase = getConsensusBaseFromOverallBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromConsensusBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusPosition(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromConsensusBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusPosition(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		return -1;	}	/*.................................................................................................................*/	private void goToNextProblem(boolean right, boolean major) {					int next = -1;		int next2 = -1;	if (window.jumpToNextAmbiguity.getValue()) {			next2 = nextAmbiguity(right);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.jumpToNextLowQuality.getValue()) {			next2 = nextLowQuality(right, window.jumpQualityThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.jumpToNextReadMatrixConflict.getValue()) {			next2 = nextReadMatrixConflict(right, window.jumpConflictThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.jumpToNextReadReadConflict.getValue()) {			next2 = nextReadReadConflict(right, window.jumpConflictThreshold.getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.jumpToNextBadSourceRead.getValue()) {			next2 = nextSourceReadIsLowerQualityAndConflicts(right, 1, 20, major);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}						/*		boolean jumpToNextDoublePeak = true;		if (jumpToNextDoublePeak) {			next2 = nextDoublePeak(right, 20);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		*/				/*		Debugg.println("||||||||||||||||||||||||||||");		for (int i=0;i < contig.getLength();i++) {				StringBuffer b = new StringBuffer();				b.append("  " + i + "          ");				for (int r=0; r<contig.getNumReadsToShow(); r++) {					Read read = contig.getRead(r);					int iBase = read.getReadBaseFromConsensusBase(i);					if (iBase>=0 && iBase<=read.getBasesLength()) {						double candidateFraction = read.getSecondaryPeakFraction(iBase);						int candidatePeakQuality =  read.getPhdBaseQuality(iBase);						b.append("     /     " + candidateFraction + "     " + candidatePeakQuality);					}				}				Debugg.println(b.toString());		}*/				//Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	private void goToNextReadReadConflict(boolean right) {		int nextLow = nextReadReadConflict(right, window.jumpConflictThreshold.getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextAmbiguity(boolean right) {		int next = nextAmbiguity(right);//		Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	private void goToNextLowQuality(boolean right) {		int nextLow = nextLowQuality(right, window.jumpQualityThreshold.getValue());//		Debugg.println("nextLow: " + nextLow);		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextReadMatrixConflict(boolean right) {		int nextLow = nextReadMatrixConflict(right, window.jumpConflictThreshold.getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*--------------------------------------*/	public  void scrollToOverallBase(int overallBase){		hbar.setValue(overallBase);		centerPanelsAtOverallPosition(overallBase);	}	/*--------------------------------------*/	public  void scrollToConsensusBase(int i){		scrollToOverallBase(getOverallBaseFromConsensusBase(i));	}	/*--------------------------------------*/	public  void scrollToMatrixBase(int i){		scrollToConsensusBase(getConsensusPositionOfMatrixPosition(i, originalData));	}	/*--------------------------------------*/	public  void scrollToConsensusBaseOffset(int i){		int newBase = centerBase+i;		if (newBase>=0 && newBase<getTotalNumPeaks()) {						hbar.setValue(newBase);			centerPanelsAtOverallPosition(newBase);		}	}	/*--------------------------------------*/	public  void adjustmentValueChanged(AdjustmentEvent evt){		if(evt.getAdjustable() == hbar) {			switch(evt.getAdjustmentType()) {			case AdjustmentEvent.UNIT_DECREMENT:			case AdjustmentEvent.UNIT_INCREMENT:			case AdjustmentEvent.BLOCK_INCREMENT:			case AdjustmentEvent.BLOCK_DECREMENT:			case AdjustmentEvent.TRACK:				centerPanelsAtOverallPosition(evt.getValue());				break;			}		}	}}class ContigLinkerPanel extends MesquitePanel implements SequenceMatchCalc{	ContigPanel parent, otherPanel;	MatrixSequence mySeq, refSeq;	String mySequence, otherSequence;	SequenceCanvas mySeqCanvas, refSeqCanvas;	Color[] match;	public ContigLinkerPanel(ContigPanel parent){		this.parent = parent;		SequencePanel mySeqPanel = parent.getSequencePanel(2);		otherPanel = (ContigPanel)parent.window.getMainContigPanel();		SequencePanel refSeqPanel = otherPanel.getSequencePanel(2);		refSeqCanvas = refSeqPanel.getCanvas();		mySeq = (MatrixSequence)mySeqPanel.getSequence();		mySeqCanvas = mySeqPanel.getCanvas();		refSeq = (MatrixSequence)refSeqPanel.getSequence();		//setBackground(Color.blue);	}	double compareStates(char char1, char char2){		long state = DNAState.fromCharStatic(char1);		long state2 = DNAState.fromCharStatic(char2);		int cardInt = CategoricalState.cardinality(state & state2);		int cardUn = CategoricalState.cardinality(state | state2);		if (cardUn == 0)			return 0;		return (cardInt*1.0/cardUn);	}	int distance = 8;	int widthHalf = 20;	public synchronized Color getBaseMatchColor(int ic){		int diff = otherCenter-center;		double s = 0;		if (parent.isShownReversed())			ic = mySequence.length() - ic;		String acO = "";		String ac = "";		//looking at a window widthHalf left and right of this site		for (int ik = ic-widthHalf; ik<= ic + widthHalf; ik++){ //surveying window			//seeing that point in window is in both sequences			if (ik>=0 && ik<mySequence.length() && ik+diff>=0 && ik+diff<otherSequence.length()){				char state = mySequence.charAt(ik);				char otherState = otherSequence.charAt(ik+diff);				if (ic == center){					ac += state;					acO += otherState;				}				s += compareStates(state, otherState);			}		}		s = s/(2.0*widthHalf +1);		double bestScore = s;  //set this as baseline best match		int bestOffset = 0;		for (int offset= -distance; offset<=distance; offset++){			int icOffset = ic + offset;			if (icOffset>=0 && icOffset<mySequence.length()){				double sD = 0;				//looking at a window widthHalf left and right of this site				for (int ik = icOffset-widthHalf; ik<= icOffset + widthHalf; ik++){ //surveying window					//seeing that point in window is in both sequences					if (ik>=0 && ik<mySequence.length() && ik+diff-offset>=0 && ik+diff-offset<otherSequence.length()){						char state = mySequence.charAt(ik);						char otherState = otherSequence.charAt(ik+diff- offset);						sD += compareStates(state, otherState);					}				}				sD = sD/(2.0*widthHalf +1);				if (sD > bestScore) {					bestScore = sD;					bestOffset = offset;				}			}		}		//bestScore = bestScore*0.7;//to soften colors		if (bestOffset>0){			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset =1;			return MesquiteColorTable.getGreenScale(bestScore/bestOffset, 0, 1, false);		}		else if (bestOffset<0){			bestOffset = - bestOffset;			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset = 1;			return MesquiteColorTable.getRedScale(bestScore/bestOffset, 0, 1, false);		}		else {			if (ic>=0 && ic<mySequence.length() && ic+diff>=0 && ic+diff<otherSequence.length()){				char state = mySequence.charAt(ic);				char otherState = otherSequence.charAt(ic+diff);				if (state == otherState){					double score = compareStates(state, otherState);					if (score > 0.9){						//if (CategoricalState.cardinality(DNAState.fromCharStatic(state))>1 || CategoricalState.cardinality(DNAState.fromCharStatic(otherState))>1){						//	Debugg.println("state " + CategoricalState.toString(DNAState.fromCharStatic(state)) + " otherState " + CategoricalState.toString(DNAState.fromCharStatic(otherState)) + " score " + score);						//}						return Color.yellow;					}				}			}			return MesquiteColorTable.getYellowScale(bestScore, 0, 2, false);		}	}	int center, otherCenter; //myLength, otherLength, 	public void paint(Graphics g){		//myLength = mySeq.getLength();		//otherLength = refSeq.getLength();		center = mySeqCanvas.getLocalIndexFromConsensus(parent.getConsensusBaseFromOverallBase(parent.getCenterBase()));		otherCenter = refSeqCanvas.getLocalIndexFromConsensus(otherPanel.getConsensusBaseFromOverallBase(otherPanel.getCenterBase()));		mySequence = mySeq.getSequence();		otherSequence = refSeq.getSequence();		//	Debugg.println("mySequence " + center + "  " + otherCenter);		if (parent.isShownComplemented())			mySequence = DNAData.complementString(mySequence);		if (parent.isShownReversed()){			mySequence = DNAData.reverseString(mySequence);			center = mySequence.length()-center;		}		/**/		/**/		//	Debugg.println("mySequenceLATER " + center + "  " + otherCenter);		if (otherPanel.isShownComplemented())			otherSequence = DNAData.complementString(otherSequence);		if (otherPanel.isShownReversed()){			otherSequence = DNAData.reverseString(otherSequence);			otherCenter = otherSequence.length()-otherCenter;		}		mySequence = mySequence.toLowerCase();		otherSequence = otherSequence.toLowerCase();//		COMPLEMENT IF NEEDED//		REVERSE IF NEEDED AND then change center		g.translate(0, -14);		mySeqCanvas.paint(g, true, this);		g.translate(0, 14);		g.setColor(Color.black);		g.fillRect(0, getBounds().height-3, getBounds().width, 3);	}}class ContigControlPanel extends MesquitePanel  {	//close (all except for base)	//close individual reads	// reverse	// complement	// name	String name;	ContigPanel parent;	MesquiteButton reverseButton, complementButton, goAwayButton;	MesquiteButton[] chromatButtons;	boolean isPrimary;	public ContigControlPanel(String name, ContigPanel parent){		this.name = name;		this.parent = parent;		this.isPrimary = parent.isPrimary;		chromatButtons = new MesquiteButton[parent.getNumChromats()];		for (int i=0; i< parent.getNumChromats(); i++){			chromatButtons[i] = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("toggleChromatVisible", parent), Integer.toString(i), true, parent.window.viewModule.getPath() + "triangleDownOn.gif", 12, 12);			chromatButtons[i].setOptionImagePath(parent.window.viewModule.getPath() + "triangleRightOn.gif");			add(chromatButtons[i]);			chromatButtons[i].setBounds(getBounds().width-20, parent.getChromatTop(i), 12, 12);			chromatButtons[i].setShowBackground(false);			chromatButtons[i].setVisible(true);			chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));		}		int top = getBounds().height-36;		complementButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showComplemented", parent), null, true, parent.window.viewModule.getPath() + "complementOff.gif", 16, 16);		complementButton.setOptionImagePath(parent.window.viewModule.getPath() + "complementOn.gif");		add(complementButton);		complementButton.setBounds(4, top, 16, 16);		top -= 20;		complementButton.setShowBackground(false);		complementButton.setVisible(true);		complementButton.setOptionDown(parent.showComplemented.getValue());		reverseButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showReversed", parent), null, true, parent.window.viewModule.getPath() + "forward.gif", 16, 16);		reverseButton.setOptionImagePath(parent.window.viewModule.getPath() + "reverse.gif");		add(reverseButton);		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setShowBackground(false);		reverseButton.setVisible(true);		reverseButton.setOptionDown(parent.showReversed.getValue());		if (!isPrimary){			goAwayButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("goAway", parent), null, true, MesquiteModule.getRootImageDirectoryPath() + "goAway.gif", 16, 16);			add(goAwayButton);			goAwayButton.setBounds(4, top, 16, 16);			goAwayButton.setShowBackground(false);			goAwayButton.setVisible(true);		}	}	void resetButtons(){		for (int i=0; i< parent.getNumChromats(); i++){			chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));			chromatButtons[i].repaint();		}	}	void resize(){		for (int i=0; i< parent.getNumChromats(); i++){			chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));			chromatButtons[i].setBounds(getBounds().width-16, parent.getChromatTop(i) +2, 12, 12);			chromatButtons[i].repaint();		}		int top = getBounds().height-36;		complementButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		if (!isPrimary){			goAwayButton.setBounds(2, top, 16, 16);		}	}	public void setSize(int w, int h){		super.setSize( w,  h);		resize();	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x, y, w,  h);		resize();	}	public void setBackground(Color c){		super.setBackground(c);		if (goAwayButton != null)			goAwayButton.setBackground(c);		complementButton.setBackground(c);		reverseButton.setBackground(c);		for (int i=0; i< parent.getNumChromats(); i++){			chromatButtons[i].setBackground(c);		}	}	public void paint(Graphics g){		g.setColor(Color.blue);		g.drawRect(0,0,getBounds().width-1, getBounds().height-1);		g.drawRect(1,1,getBounds().width-3, getBounds().height-3);	}}/* ======================================================================== */class ChromWindowPalette extends ToolPalette {	VChromWindow w;	MiniSlider slider;	public ChromWindowPalette(MesquiteModule ownerModule, VChromWindow containingWindow, MesquiteCommand sliderCommand) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 1);		w = containingWindow;		slider = new MiniSlider (sliderCommand, false, 4, 0, 5, 0, 5);		add(slider);		slider.setVisible(true);		slider.setBounds(20, 100, 10, 200);	}	public void setSize(int width, int height){		super.setSize(width, height);		slider.setSize(16, 80);		slider.setLocation(width/2-10, height-100);	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		slider.setSize(16, 80);		slider.setLocation(width/2-10, height-100);	}}/*class SequenceIterator {	MatrixSequence seq;	MolecularData data;	MesquiteInteger currentMatrixIC, currentSeqIC;	MesquiteBoolean firstHit = new MesquiteBoolean(false);	public SequenceIterator(MolecularData data, MatrixSequence seq){		this.data = data;		this.seq = seq;		currentMatrixIC = new MesquiteInteger(0);		currentSeqIC = new MesquiteInteger(0);	}	public void reset(){		firstHit.setValue(false);		currentMatrixIC.setValue(0);		currentSeqIC.setValue(0);	}	public long getSite(int ic, boolean verb){if (verb)	Debugg.println("target " + ic + "  currentSeqIC " + currentSeqIC + "  currentMatrixIC " + currentMatrixIC + "  firstHit " + firstHit);			if (ic >= currentSeqIC.getValue())			return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 		reset();		return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 	}} */