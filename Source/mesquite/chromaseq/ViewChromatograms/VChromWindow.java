/* Mesquite chromaseq source code.  Copyright 2005-2009 D. Maddison and W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms;import java.io.*;import java.util.*;import java.net.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.table.*;import mesquite.lib.characters.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.meristic.lib.*;import mesquite.chromaseq.lib.*;//Todo: This and contained panels should be within ViewChromatograms as they are designed to be used by only that one module/* ======================================================================== */public class VChromWindow extends ChromatWindow implements MesquiteListener, XMLPreferencesProcessor {	String title;	int vMargin = 20;	MesquiteTable table; //data matrix table	DNAData data;	DNAData originalData;	ContinuousData qualityData;	MeristicData registryData;	int defaultWidth = 1000;	int defaultHeight = 400;	String xmlPrefsString = null;	static boolean preferencesProcessed=false;	ChromatogramViewer viewModule;	MesquiteBoolean showControls;	private Cursor handCursor;	static Image leftArrow, rightArrow;	ContigPanel contigPanel;	Vector extraContigs;	MesquiteModule windowServer;	MesquiteBoolean sequencesLocked = new MesquiteBoolean(false);	Color backgroundColor = Color.white;	MesquiteString singlePrimer = new MesquiteString("");	MesquiteMenuItemSpec	showFadesMenuItem;	static Color AColorSequencher =  new Color((float)0.1, (float)0.95, (float)0.1);	static Color CColorSequencher = Color.blue;	static Color GColorSequencher = Color.black;	static Color TColorSequencher = Color.red;	static Color AColorStandard = DNAData.dnaRed;	static Color CColorStandard  = DNAData.dnaGreen;	static Color GColorStandard  = DNAData.dnaYellow;	static Color TColorStandard = DNAData.dnaBlue;//	============ USER OPTION boolean	public static final int SHOWBASESOURCE = 0;	public static final int FADENONSOURCEREAD = 1;	public static final int SHOWACECONTIGPANEL = 2;	public static final int SHOWORIGINALIMPORTPANEL=3;	public static final int CHROMATOGRAMSONTOP=4;	public static final int SHOWMULTIREADCALLSPANEL=5;	public static final int SHOWOVERVIEWPANEL=6;	public static final int FIXEDCHROMATOHEIGHT=7;	public static final int COLORIMPORTEDBYQUALITY=8;	public static final int COLORMULTIREADCALLSBYQUALITY=9;	public static final int COLOREDITEDINMATRIXBYQUALITY=10;	public static final int COLOROVERVIEWBYQUALITY=11;	public static final int USESEQUENCHERCOLORS = 12;	public static final int  FADENONSOURCELOWERQUALITYREADS = 13;	public static final int COLORREADCALLSBYQUALITY=14;	public static final int THICKTRACE = 15;	public static final int FADELOWQUALITY=16;	public static final int SHOWREADMATRIXCONFLICT=17;	public static final int SHOWREADREADCONFLICT=18;	public static final int SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD=19;	public static final int SHOWREADNAME=20;	public static final int DIMLOWQUALITYCONFLICTS=21;	public static final int SHOWCODONPOSITION=22;	public static final int SHOWFADES=23;	public static final int SCROLLTOTOUCHED=24;		public static final int TURNOFFEDITONMOVE=25;	public static final int IGNOREPROBLEMIFBASECALLED=26;	public static final int JUMPTONEXTBASE = 27;	public static final int JUMPTONEXTREADREADCONFLICT =28;	public static final int JUMPTONEXTREADMATRIXCONFLICT =29;	public static final int JUMPTONEXTLOWQUALITY =30;	public static final int JUMPTONEXTAMBIGUITY =31;	public static final int JUMPTONEXTBADSOURCEREAD=32;		public static final int numChromBooleans = 33;	static boolean[] factoryDefaultChromBoolean =new boolean[numChromBooleans];	static boolean[] defaultChromBoolean =new boolean[numChromBooleans];	MesquiteBoolean[] chromBoolean = new MesquiteBoolean[numChromBooleans];	static { 		for (int i=0;i<numChromBooleans;i++)			factoryDefaultChromBoolean[i] = true;   // turn them all true, then only turn off the ones that are needed		factoryDefaultChromBoolean[JUMPTONEXTBASE] = false;		factoryDefaultChromBoolean[SHOWORIGINALIMPORTPANEL] = false;		factoryDefaultChromBoolean[SHOWMULTIREADCALLSPANEL] = false;		factoryDefaultChromBoolean[FADENONSOURCEREAD] = false;		factoryDefaultChromBoolean[FADENONSOURCELOWERQUALITYREADS] = false;		factoryDefaultChromBoolean[THICKTRACE] = ChromatogramPanel.THICKTRACEDEFAULT;		factoryDefaultChromBoolean[FADELOWQUALITY] = false;		factoryDefaultChromBoolean[SHOWCODONPOSITION] = false;		factoryDefaultChromBoolean[SHOWREADMATRIXCONFLICT] = ChromatogramPanel.SHOWREADMATRIXCONFLICTDEFAULT;		factoryDefaultChromBoolean[SCROLLTOTOUCHED] = false;		for (int i=0;i<numChromBooleans;i++){			defaultChromBoolean[i] = factoryDefaultChromBoolean[i];		}	}//	============ USER OPTION integers	public static final int FADELOWQUALITYTHRESHOLD = 0;	public static final int DIMCONFLICTMARKERTHRESHOLD = 1;	public static final int JUMPQUALITYTHRESHOLD = 2;	public static final int JUMPCONFLICTTHRESHOLD=3;		public static final int numChromInts = 4;	static int[] factoryDefaultChromInt =new int[numChromInts];	static int[] defaultChromInt =new int[numChromInts];	MesquiteInteger[] chromInt = new MesquiteInteger[numChromInts];	static { 		for (int i=0;i<numChromInts;i++)			factoryDefaultChromInt[i] = 0;   // turn them all true, then only turn off the ones that are needed		factoryDefaultChromInt[FADELOWQUALITYTHRESHOLD] = 20;		factoryDefaultChromInt[DIMCONFLICTMARKERTHRESHOLD] = 30;		factoryDefaultChromInt[JUMPQUALITYTHRESHOLD] = 30;		factoryDefaultChromInt[JUMPCONFLICTTHRESHOLD] = 30;		for (int i=0;i<numChromInts;i++){			defaultChromInt[i] = factoryDefaultChromInt[i];		}	}//	=============	MesquiteBoolean showA;	MesquiteBoolean showC;	MesquiteBoolean showG;	MesquiteBoolean showT;	MesquiteBoolean useBTOLDatabase = new MesquiteBoolean(false);	MesquiteBoolean showPrimerMatches = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWPRIMERS);	MesquiteBoolean showSinglePrimerMatch = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWSINGLEPRIMERMATCH);	MesquiteBoolean enableShadowReduction = new MesquiteBoolean(false);	/* ======================================================================== */	public VChromWindow(ChromatogramViewer module, MesquiteModule windowServer, MesquiteTable table, CharacterData data, Taxon taxon, String title, Chromatogram[] chroms, Contig contig, Read[] reads, String xmlPrefsString) {			super(windowServer, xmlPrefsString, true);		this.xmlPrefsString = xmlPrefsString;		this.windowServer = windowServer;		this.viewModule = module;		extraContigs = new Vector();		handCursor = new Cursor(Cursor.HAND_CURSOR);		for (int i=0;i<numChromBooleans; i++)			chromBoolean[i]= new MesquiteBoolean(factoryDefaultChromBoolean[i]);		for (int i=0;i<numChromInts; i++) 			chromInt[i]= new MesquiteInteger(factoryDefaultChromInt[i]);		setWindowSize(defaultWidth, defaultHeight + 16+36);		if (leftArrow == null){			leftArrow = MesquiteImage.getImage(module.getPath()+"arrowLeft.gif");			rightArrow = MesquiteImage.getImage(module.getPath()+"arrowRight.gif");		}
		//windowServer.addMenuItem(null, "Reverse Complement", MesquiteModule.makeCommand("reverseComplement", this));
		showControls = new MesquiteBoolean(true);		windowServer.addMenuItem("Show Matrix", MesquiteModule.makeCommand("showMatrix", this));
		MesquiteSubmenuSpec mss3 = windowServer.addSubmenu(null, "Styles");		windowServer.addItemToSubmenu(null,mss3,"Standard", MesquiteModule.makeCommand("styleStandard", this));		windowServer.addItemToSubmenu(null,mss3,"Corvallis Style", MesquiteModule.makeCommand("styleCorvallis", this));		windowServer.addItemToSubmenu(null,mss3,"Vancouver Style", MesquiteModule.makeCommand("styleVancouver", this));		windowServer.addItemToSubmenu(null,mss3,"Phoenix Style", MesquiteModule.makeCommand("stylePhoenix", this));		windowServer.addMenuItem("Save Current Settings as Defaults", MesquiteModule.makeCommand("saveDefaults", this));		windowServer.addMenuLine();		//-----------------		MesquiteSubmenuSpec viewSubmenu = windowServer.addSubmenu(null, "View");		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Chromatograms on Top", MesquiteModule.makeCommand("toggleChromatogramsOnTop",  this), chromBoolean[CHROMATOGRAMSONTOP]);		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Fixed-height Chromatograms", MesquiteModule.makeCommand("toggleFixedChromatoHeight",  this), chromBoolean[FIXEDCHROMATOHEIGHT]);		MesquiteSubmenuSpec mss = windowServer.addSubmenu(null, "Show");		showA = new MesquiteBoolean(true);		showC = new MesquiteBoolean(true);		showG = new MesquiteBoolean(true);		showT = new MesquiteBoolean(true);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Overview Panel", MesquiteModule.makeCommand("toggleShowOverviewPanel",  this), chromBoolean[SHOWOVERVIEWPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Multi-Read Panel", MesquiteModule.makeCommand("toggleShowMultiReadCallsPanel",  this), chromBoolean[SHOWMULTIREADCALLSPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Original Phred Phrap Mesquite", MesquiteModule.makeCommand("toggleShowAceContigPanel",  this), chromBoolean[SHOWACECONTIGPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Original Trimmed Sequence", MesquiteModule.makeCommand("toggleShowOriginalImportPanel",  this), chromBoolean[SHOWORIGINALIMPORTPANEL]);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "A Trace", MesquiteModule.makeCommand("toggleShowA",  this), showA);		windowServer.addCheckMenuItemToSubmenu(null, mss, "C Trace", MesquiteModule.makeCommand("toggleShowC",  this), showC);		windowServer.addCheckMenuItemToSubmenu(null, mss, "G Trace", MesquiteModule.makeCommand("toggleShowG",  this), showG);		windowServer.addCheckMenuItemToSubmenu(null, mss, "T Trace", MesquiteModule.makeCommand("toggleShowT",  this), showT);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Base Source", MesquiteModule.makeCommand("toggleShowBaseSource", this), chromBoolean[SHOWBASESOURCE]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Codon Position", MesquiteModule.makeCommand("toggleShowCodonPosition", this), chromBoolean[SHOWCODONPOSITION]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Read Name", MesquiteModule.makeCommand("toggleShowReadName", this), chromBoolean[SHOWREADNAME]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Control Bar", MesquiteModule.makeCommand("showControls", this), showControls);		MesquiteSubmenuSpec mss2 = windowServer.addSubmenu(null, "Color Calls by Quality Scores");		windowServer.addCheckMenuItemToSubmenu(null, mss2,"Individual Reads", MesquiteModule.makeCommand("toggleColorReadCallsByQuality", this), chromBoolean[COLORREADCALLSBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Edited in Matrix Sequence", MesquiteModule.makeCommand("toggleColorEditedInMatrixByQuality", this), chromBoolean[COLOREDITEDINMATRIXBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null, mss2,"Imported Sequences", MesquiteModule.makeCommand("toggleColorImportedByQuality", this), chromBoolean[COLORIMPORTEDBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Multi-Read Panel", MesquiteModule.makeCommand("toggleColorMultiReadByQuality", this), chromBoolean[COLORMULTIREADCALLSBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Overview", MesquiteModule.makeCommand("toggleColorOverviewByQuality", this), chromBoolean[COLOROVERVIEWBYQUALITY]);		windowServer.addCheckMenuItem(null, "Thick Trace Lines", MesquiteModule.makeCommand("toggleThickTrace", this), chromBoolean[THICKTRACE]);		windowServer.addCheckMenuItem(null, "Use Sequencher Colors", MesquiteModule.makeCommand("toggleUseSequencherColors", this), chromBoolean[USESEQUENCHERCOLORS]);		windowServer.addMenuLine();		//-----------------		windowServer.addCheckMenuItem(null, "Enable Shadow Reduction", MesquiteModule.makeCommand("toggleShadowReduction", this), enableShadowReduction);		windowServer.addCheckMenuItem(null, "Center Where Touched", MesquiteModule.makeCommand("toggleScrollToTouched", this), chromBoolean[SCROLLTOTOUCHED]);		windowServer.addCheckMenuItem(null, "Deselect Single Selection on Scroll", MesquiteModule.makeCommand("toggleTurnOffEditOnMove", this), chromBoolean[TURNOFFEDITONMOVE]);		MesquiteSubmenuSpec navSubmenu = windowServer.addSubmenu(null, "Arrow Keys");		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Move To Next Base", MesquiteModule.makeCommand("toggleJumpToNextBase",  this), chromBoolean[JUMPTONEXTBASE]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleJumpToNextBadSource",  this), chromBoolean[JUMPTONEXTBADSOURCEREAD]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Matrix Conflict", MesquiteModule.makeCommand("toggleJumpToNextReadMatrixConflict",  this), chromBoolean[JUMPTONEXTREADMATRIXCONFLICT]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Read Conflict", MesquiteModule.makeCommand("toggleJumpToNextConflict",  this), chromBoolean[JUMPTONEXTREADREADCONFLICT]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Low Quality", MesquiteModule.makeCommand("toggleJumpToNextLowQuality",  this), chromBoolean[JUMPTONEXTLOWQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Ambiguity", MesquiteModule.makeCommand("toggleJumpToNextAmbiguity",  this), chromBoolean[JUMPTONEXTAMBIGUITY]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Ignore Problem if Base Called", MesquiteModule.makeCommand("toggleIgnoreProblemIfBaseCalled",  this), chromBoolean[IGNOREPROBLEMIFBASECALLED]);		windowServer.addLineToSubmenu(null,navSubmenu);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Conflict Threshold...", MesquiteModule.makeCommand("setJumpConflictThreshold",  this));		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Quality Threshold...", MesquiteModule.makeCommand("setJumpQualityThreshold",  this));		windowServer.addMenuLine();		//-----------------		MesquiteSubmenuSpec primerSubmenu = windowServer.addSubmenu(null, "Primers");		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu,"Show Primer Matches", MesquiteModule.makeCommand("showPrimerMatches",  this), showPrimerMatches);		windowServer.addItemToSubmenu(null, primerSubmenu, "Set Primer File ...", MesquiteModule.makeCommand("setPrimerSequenceFile",  this));		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu,"Use BTOL Database", MesquiteModule.makeCommand("useBTOLDatabase",  this), useBTOLDatabase);		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu, "Show Single Primer Match", MesquiteModule.makeCommand("showSinglePrimerMatch",  this), showSinglePrimerMatch);		windowServer.addItemToSubmenu(null, primerSubmenu, "Specify Single Primer ...", MesquiteModule.makeCommand("setSinglePrimer",  this));		windowServer.addMenuItem( "Show Extra Sequence...", MesquiteModule.makeCommand("showExtraContig",  this));		windowServer.addCheckMenuItem( null, "Lock Extra sequences", MesquiteModule.makeCommand("lockSequences",  this), sequencesLocked);		windowServer.addMenuLine();		//-----------------		windowServer.addCheckMenuItem(null, "Show Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleShowLowerQualSourceConflictsWithHigherQualRead", this), chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD]);		windowServer.addCheckMenuItem(null, "Show Read-Matrix Conflict", MesquiteModule.makeCommand("toggleShowChromMatrixDisagreement", this), chromBoolean[SHOWREADMATRIXCONFLICT]);		windowServer.addCheckMenuItem(null, "Show Read-Read Conflict", MesquiteModule.makeCommand("toggleShowReadReadConflict", this), chromBoolean[SHOWREADREADCONFLICT]);		windowServer.addCheckMenuItem(null, "Dim Conflict Markers if Low Quality", MesquiteModule.makeCommand("toggleDimLowQualityConflicts", this), chromBoolean[DIMLOWQUALITYCONFLICTS]);		windowServer.addMenuItem( "Dim Conflict Marker Threshold...", MesquiteModule.makeCommand("setDimConflictMarkerTheshold",  this));		windowServer.addMenuLine();		//-----------------				showFadesMenuItem = windowServer.addMenuItem("Show Fades", MesquiteModule.makeCommand("toggleFades", this));		showFadesMenuItem.setShortcut(KeyEvent.VK_D); 		windowServer.addCheckMenuItem(null, "Fade Low Quality", MesquiteModule.makeCommand("toggleFadeLowQuality", this), chromBoolean[FADELOWQUALITY]);		windowServer.addMenuItem( "Fade Quality Threshold...", MesquiteModule.makeCommand("setFadeThreshold",  this));		windowServer.addCheckMenuItem(null, "Fade Non-Source Read", MesquiteModule.makeCommand("toggleFadeNonSourceRead", this), chromBoolean[FADENONSOURCEREAD]);		windowServer.addCheckMenuItem(null, "Fade Non-Source Lower-Quality Read", MesquiteModule.makeCommand("toggleFadeNonSourceLowerQualityRead", this), chromBoolean[FADENONSOURCELOWERQUALITYREADS]);		windowServer.addMenuLine();		//-----------------		this.title = title;		this.table = table;		this.data = (DNAData)data;		setAnnotation(taxon.getName() + " (in matrix " + data.getName() + ")", null);		originalData = ChromaseqUtil.getOriginalData(data);		qualityData = ChromaseqUtil.getQualityData(data);		registryData = ChromaseqUtil.getRegistryData(data);		if (originalData == null) {			originalData = (DNAData)data;		}		if (data != null)			data.addListener(this);		if (originalData != null)			originalData.addListener(this);		if (qualityData != null)			qualityData.addListener(this);				if (registryData==null) {			registryData = ChromaseqUtil.createRegistryData(data);					}		contigPanel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, true);		if (totalCreated<=1)   // only do it first time			XMLUtil.readXMLPreferences(viewModule,this, xmlPrefsString);		for (int i=0;i<numChromBooleans; i++) {			chromBoolean[i].setValue(defaultChromBoolean[i]);		}		for (int i=0;i<numChromInts; i++) {			chromInt[i].setValue(defaultChromInt[i]);		}		initializeContigPanelSettings(contigPanel);		addToWindow(contigPanel);		//infoPanel = new InfoPanel(taxon.getName());		//addToWindow(infoPanel);//		sizeDisplays()		ChromatogramTool arrowTool = new ChromatogramTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(),"arrow.gif", 4,2,"Select", "Selection tool", MesquiteModule.makeCommand("arrowTouch",  this) , MesquiteModule.makeCommand("arrowDrop",  this), null);		arrowTool.setIsArrowTool(true);		addTool(arrowTool);		setCurrentTool(arrowTool);		arrowTool.setInUse(true);		setShowAnnotation(true);		setShowExplanation(true);		resetTitle();		sizeDisplays();		SequencePanel[] sequences = new SequencePanel[]{contigPanel.aceContigPanel, contigPanel.origSeqPanel, contigPanel.matrixSeqPanel};		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).setWindow(this);				((ChromInit)e).addContext(taxon, contig, contigPanel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, contigPanel.getID());			}		}		 adjustChromInitsIfPositionChanges();		contigPanel.requestFocusInWindow();	}		/*.................................................................................................................*/	private void setChromInt(int i,int value) {		chromInt[i].setValue(value);		defaultChromInt[i] =value;		switch(i) {		case FADELOWQUALITYTHRESHOLD:			setFadeQualityThreshold(value);			break;		case DIMCONFLICTMARKERTHRESHOLD:			setDimConflictMarkerThreshold(value);			break;		default: ;		}	}	/*.................................................................................................................*/	private void setChromBoolean(int i, boolean b) {		chromBoolean[i].setValue(b);		defaultChromBoolean[i] =b;		switch (i) {		case SHOWBASESOURCE: 			setShowBaseSource(b);			break;		case FADENONSOURCEREAD:			setFadeNonSourceRead(b);			break;		case SHOWACECONTIGPANEL:			contigPanel.setShowAceContigPanel(b);			break;		case SHOWORIGINALIMPORTPANEL:			contigPanel.setShowOriginalImportPanel(b);			break;		case CHROMATOGRAMSONTOP: 			contigPanel.setChromatogramsOnTop(b);			 adjustChromInitsIfPositionChanges();			break;		case SHOWMULTIREADCALLSPANEL:			contigPanel.setShowMultiReadCallsPanel(b);			break;		case SHOWOVERVIEWPANEL:			contigPanel.setShowOverviewPanel(b);			break;		case FIXEDCHROMATOHEIGHT:			contigPanel.setFixedChromatoHeight(b);			break;		case COLORIMPORTEDBYQUALITY:			setColorImportedByQuality(b);			break;		case COLORREADCALLSBYQUALITY:			setColorReadCallsByQuality(b);			break;		case COLORMULTIREADCALLSBYQUALITY:			setColorMultiReadByQuality(b);			break;		case COLOREDITEDINMATRIXBYQUALITY:			setColorEditedInMatrixByQuality(b);			break;		case COLOROVERVIEWBYQUALITY:			setColorOverviewByQuality(b);			break;		case USESEQUENCHERCOLORS: 			setUseSequencherColors(b);			break;		case FADENONSOURCELOWERQUALITYREADS: 			setFadeNonSourceLowerQualityRead(b);			break;		case THICKTRACE:			setThickTrace(b);			break;		case FADELOWQUALITY:			setFadeLowQuality(b);			break;		case SHOWREADMATRIXCONFLICT:			setShowReadMatrixConflict(b);			break;		case SHOWREADREADCONFLICT:			setShowReadReadConflict(b);			break;		case SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD:			setShowLowerQualSourceConflictsWithHigherQualRead(b);			break;		case SHOWREADNAME:			setShowReadName(b);			break;		case DIMLOWQUALITYCONFLICTS:			setDimLowQualityConflicts(b);			break;		case SHOWCODONPOSITION:			setShowCodonPosition(b);			break;		case SHOWFADES:			setShowFades(b);			break;		case SCROLLTOTOUCHED:			setScrollToTouched(b);			break;		case JUMPTONEXTBASE:			recheckJumps(i);			break;		case JUMPTONEXTREADREADCONFLICT:			recheckJumps(i);			break;		case JUMPTONEXTREADMATRIXCONFLICT:			recheckJumps(i);			break;		case JUMPTONEXTLOWQUALITY:			recheckJumps(i);			break;		case JUMPTONEXTAMBIGUITY:			recheckJumps(i);			break;		case JUMPTONEXTBADSOURCEREAD:			recheckJumps(i);			break;			default: ;		}	}		/*.................................................................................................................*/	public void recheckJumps(int i) {		switch(i) {		case JUMPTONEXTBASE:			if (chromBoolean[JUMPTONEXTBASE].getValue()) {				chromBoolean[JUMPTONEXTREADREADCONFLICT].setValue(false);				chromBoolean[JUMPTONEXTLOWQUALITY].setValue(false);				chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].setValue(false);				chromBoolean[JUMPTONEXTAMBIGUITY].setValue(false);				chromBoolean[JUMPTONEXTBADSOURCEREAD].setValue(false);			}			break;		case JUMPTONEXTREADREADCONFLICT:			if (chromBoolean[JUMPTONEXTREADREADCONFLICT].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTREADMATRIXCONFLICT:			if (chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTLOWQUALITY:			if (chromBoolean[JUMPTONEXTLOWQUALITY].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTAMBIGUITY:			if (chromBoolean[JUMPTONEXTAMBIGUITY].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTBADSOURCEREAD:			if (chromBoolean[JUMPTONEXTBADSOURCEREAD].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		}	}	/*.................................................................................................................*/	private void setChromBoolean(int i, String toggleString) {		chromBoolean[i].toggleValue(toggleString);		setChromBoolean(i,chromBoolean[i].getValue());	}	/*.................................................................................................................*/	public void processSingleXMLPreference (String tag, String content) {		if (!preferencesProcessed) {   //only process these ones first time through			if ("showAceContigPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWACECONTIGPANEL, MesquiteBoolean.fromTrueFalseString(content));			else if ("showOriginalImportPanel".equalsIgnoreCase(tag)) 				setChromBoolean(SHOWORIGINALIMPORTPANEL, MesquiteBoolean.fromTrueFalseString(content));			else if ("chromatogramsOnTop".equalsIgnoreCase(tag))				setChromBoolean(CHROMATOGRAMSONTOP, MesquiteBoolean.fromTrueFalseString(content));			else if ("showMultiReadCallsPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWMULTIREADCALLSPANEL, MesquiteBoolean.fromTrueFalseString(content));			else if ("showOverviewPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWOVERVIEWPANEL, MesquiteBoolean.fromTrueFalseString(content));			else if ("fixedChromatoHeight".equalsIgnoreCase(tag))				setChromBoolean(FIXEDCHROMATOHEIGHT, MesquiteBoolean.fromTrueFalseString(content));			else if ("fadeNonSourceRead".equalsIgnoreCase(tag))				setChromBoolean(FADENONSOURCEREAD, MesquiteBoolean.fromTrueFalseString(content));			else if ("showBaseSource".equalsIgnoreCase(tag))				setChromBoolean(SHOWBASESOURCE, MesquiteBoolean.fromTrueFalseString(content));			else if ("colorImportedByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORIMPORTEDBYQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("colorReadCallsByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORREADCALLSBYQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("colorMultiReadByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORMULTIREADCALLSBYQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("colorOverviewByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLOROVERVIEWBYQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("colorEditedInMatrixByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("useSequencherColors".equalsIgnoreCase(tag))				setChromBoolean(USESEQUENCHERCOLORS,MesquiteBoolean.fromTrueFalseString(content));			else if ("fadeNonSourceLowerQualityRead".equalsIgnoreCase(tag))				setChromBoolean(FADENONSOURCELOWERQUALITYREADS,MesquiteBoolean.fromTrueFalseString(content));			else if ("thickTrace".equalsIgnoreCase(tag))				setChromBoolean(THICKTRACE,MesquiteBoolean.fromTrueFalseString(content));			else if ("fadeLowQuality".equalsIgnoreCase(tag))				setChromBoolean(FADELOWQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("showReadMatrixConflict".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADMATRIXCONFLICT,MesquiteBoolean.fromTrueFalseString(content));			else if ("showReadReadConflict".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADREADCONFLICT,MesquiteBoolean.fromTrueFalseString(content));			else if ("showLowerQualSourceConflictsWithHigherQualRead".equalsIgnoreCase(tag))				setChromBoolean(SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD,MesquiteBoolean.fromTrueFalseString(content));			else if ("showReadName".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADNAME,MesquiteBoolean.fromTrueFalseString(content));			else if ("dimLowQualityConflicts".equalsIgnoreCase(tag))				setChromBoolean(DIMLOWQUALITYCONFLICTS,MesquiteBoolean.fromTrueFalseString(content));			else if ("showCodonPosition".equalsIgnoreCase(tag))				setChromBoolean(SHOWCODONPOSITION,MesquiteBoolean.fromTrueFalseString(content));			else if ("showFades".equalsIgnoreCase(tag))				setChromBoolean(SHOWFADES,MesquiteBoolean.fromTrueFalseString(content));			else if ("scrollToTouched".equalsIgnoreCase(tag))				setChromBoolean(SCROLLTOTOUCHED,MesquiteBoolean.fromTrueFalseString(content));			else if ("turnOffEditOnMove".equalsIgnoreCase(tag))				setChromBoolean(TURNOFFEDITONMOVE,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextBase".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTBASE,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextReadReadConflict".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTREADREADCONFLICT,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextReadMatrixConflict".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTREADMATRIXCONFLICT,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextLowQuality".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTLOWQUALITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextAmbiguity".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTAMBIGUITY,MesquiteBoolean.fromTrueFalseString(content));			else if ("ignoreProblemIfBaseCalled".equalsIgnoreCase(tag))				setChromBoolean(IGNOREPROBLEMIFBASECALLED,MesquiteBoolean.fromTrueFalseString(content));			else if ("jumpToNextBadSourceRead".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTBADSOURCEREAD,MesquiteBoolean.fromTrueFalseString(content));						else if ("fadeLowQualityThreshold".equalsIgnoreCase(tag))				setChromInt(FADELOWQUALITYTHRESHOLD,MesquiteInteger.fromString(content));			else if ("dimConflictMarkerThreshold".equalsIgnoreCase(tag))				setChromInt(DIMCONFLICTMARKERTHRESHOLD,MesquiteInteger.fromString(content));			else if ("jumpQualityThreshold".equalsIgnoreCase(tag))				setChromInt(JUMPQUALITYTHRESHOLD,MesquiteInteger.fromString(content));			else if ("jumpConflictThreshold".equalsIgnoreCase(tag))				setChromInt(JUMPCONFLICTTHRESHOLD,MesquiteInteger.fromString(content));		}		else if ("showPrimerMatches".equalsIgnoreCase(tag))			showPrimerMatches.setFromTrueFalseString(content);		else if ("useBTOLDatabase".equalsIgnoreCase(tag))			useBTOLDatabase.setFromTrueFalseString(content);		else if ("showSinglePrimerMatch".equalsIgnoreCase(tag))			showSinglePrimerMatch.setFromTrueFalseString(content);		else if ("enableShadowReduction".equalsIgnoreCase(tag))			enableShadowReduction.setFromTrueFalseString(content);				else if ("showA".equalsIgnoreCase(tag))			showA.setFromTrueFalseString(content);		else if ("showC".equalsIgnoreCase(tag))			showC.setFromTrueFalseString(content);		else if ("showG".equalsIgnoreCase(tag))			showG.setFromTrueFalseString(content);		else if ("showT".equalsIgnoreCase(tag))			showT.setFromTrueFalseString(content);		preferencesProcessed = true;	}	/*.................................................................................................................*/	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer(60);			StringUtil.appendXMLTag(buffer, 2, "chromatogramsOnTop", chromBoolean[CHROMATOGRAMSONTOP]);  		StringUtil.appendXMLTag(buffer, 2, "fixedChromatoHeight", chromBoolean[FIXEDCHROMATOHEIGHT]);  		StringUtil.appendXMLTag(buffer, 2, "showAceContigPanel",chromBoolean[SHOWACECONTIGPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showMultiReadCallsPanel",chromBoolean[SHOWMULTIREADCALLSPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showOverviewPanel",chromBoolean[SHOWOVERVIEWPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showOriginalImportPanel",chromBoolean[SHOWORIGINALIMPORTPANEL]);		StringUtil.appendXMLTag(buffer, 2, "colorImportedByQuality",chromBoolean[COLORIMPORTEDBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorReadCallsByQuality",chromBoolean[COLORREADCALLSBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorMultiReadByQuality",chromBoolean[COLORMULTIREADCALLSBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorOverviewByQuality",chromBoolean[COLOROVERVIEWBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorEditedInMatrixByQuality",chromBoolean[COLOREDITEDINMATRIXBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "useSequencherColors",chromBoolean[USESEQUENCHERCOLORS]);		StringUtil.appendXMLTag(buffer, 2, "thickTrace",chromBoolean[THICKTRACE]);		StringUtil.appendXMLTag(buffer, 2, "fadeLowQuality",chromBoolean[FADELOWQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "fadeNonSourceRead",chromBoolean[FADENONSOURCEREAD]);		StringUtil.appendXMLTag(buffer, 2, "fadeNonSourceLowerQualityRead",chromBoolean[FADENONSOURCELOWERQUALITYREADS]);		StringUtil.appendXMLTag(buffer, 2, "showReadMatrixConflict",chromBoolean[SHOWREADMATRIXCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "showReadReadConflict",chromBoolean[SHOWREADREADCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "showLowerQualSourceConflictsWithHigherQualRead",chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD]);		StringUtil.appendXMLTag(buffer, 2, "showReadName",chromBoolean[SHOWREADNAME]);		StringUtil.appendXMLTag(buffer, 2, "dimLowQualityConflicts",chromBoolean[DIMLOWQUALITYCONFLICTS]);		StringUtil.appendXMLTag(buffer, 2, "scrollToTouched",chromBoolean[SCROLLTOTOUCHED]);		StringUtil.appendXMLTag(buffer, 2, "turnOffEditOnMove",chromBoolean[TURNOFFEDITONMOVE]);		StringUtil.appendXMLTag(buffer, 2, "showBaseSource",chromBoolean[SHOWBASESOURCE]);		StringUtil.appendXMLTag(buffer, 2, "showCodonPosition",chromBoolean[SHOWCODONPOSITION]);		StringUtil.appendXMLTag(buffer, 2, "showFades",chromBoolean[SHOWFADES]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextBase",chromBoolean[JUMPTONEXTBASE]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextReadReadConflict",chromBoolean[JUMPTONEXTREADREADCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextReadMatrixConflict",chromBoolean[JUMPTONEXTREADMATRIXCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextLowQuality",chromBoolean[JUMPTONEXTLOWQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextAmbiguity",chromBoolean[JUMPTONEXTAMBIGUITY]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextBadSourceRead",chromBoolean[JUMPTONEXTBADSOURCEREAD]);		StringUtil.appendXMLTag(buffer, 2, "ignoreProblemIfBaseCalled",chromBoolean[IGNOREPROBLEMIFBASECALLED]);		StringUtil.appendXMLTag(buffer, 2, "fadeLowQualityThreshold",chromInt[FADELOWQUALITYTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "dimConflictMarkerThreshold",chromInt[DIMCONFLICTMARKERTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "jumpQualityThreshold",chromInt[JUMPQUALITYTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "jumpConflictThreshold",chromInt[JUMPCONFLICTTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "showA",showA);		StringUtil.appendXMLTag(buffer, 2, "showC",showC);		StringUtil.appendXMLTag(buffer, 2, "showG",showG);		StringUtil.appendXMLTag(buffer, 2, "showT",showT);		StringUtil.appendXMLTag(buffer, 2, "showPrimerMatches",showPrimerMatches);		StringUtil.appendXMLTag(buffer, 2, "useBTOLDatabase",useBTOLDatabase);		StringUtil.appendXMLTag(buffer, 2, "showSinglePrimerMatch",showSinglePrimerMatch);		StringUtil.appendXMLTag(buffer, 2, "enableShadowReduction",enableShadowReduction);		return buffer.toString();	}	/*.................................................................................................................*/	public void setToStandardStyle () {		for (int i=0; i<numChromBooleans; i++)			setChromBoolean(i,factoryDefaultChromBoolean[i]);	}	/*.................................................................................................................*/	public void setToDRMStyle () {		setChromBoolean(SHOWBASESOURCE,true);				setChromBoolean(SHOWACECONTIGPANEL,false);		setChromBoolean(SHOWORIGINALIMPORTPANEL,false);		setChromBoolean(SHOWMULTIREADCALLSPANEL,false);		setChromBoolean(SHOWOVERVIEWPANEL,true);				setChromBoolean(CHROMATOGRAMSONTOP,true);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);				setChromBoolean(COLORIMPORTEDBYQUALITY,true);		setChromBoolean(COLORREADCALLSBYQUALITY,true);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,true);				setChromBoolean(FADENONSOURCELOWERQUALITYREADS,true);		setChromBoolean(SHOWFADES,false);				setChromBoolean(THICKTRACE,true);		setChromBoolean(SHOWREADMATRIXCONFLICT,false);	}	/*.................................................................................................................*/	public void setToWPMStyle () {		setChromBoolean(SHOWBASESOURCE,true);				setChromBoolean(SHOWACECONTIGPANEL,false);		setChromBoolean(SHOWORIGINALIMPORTPANEL,false);		setChromBoolean(SHOWMULTIREADCALLSPANEL,true);		setChromBoolean(SHOWOVERVIEWPANEL,true);				setChromBoolean(CHROMATOGRAMSONTOP,false);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);		setChromBoolean(COLORIMPORTEDBYQUALITY,false);		setChromBoolean(COLORREADCALLSBYQUALITY,false);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(THICKTRACE,true);		setChromBoolean(SHOWREADMATRIXCONFLICT,true);		setChromBoolean(SCROLLTOTOUCHED,true);	}	/*.................................................................................................................*/	public void setToAEAStyle () {		setChromBoolean(SHOWBASESOURCE,false);		setChromBoolean(SHOWACECONTIGPANEL,false);		setChromBoolean(SHOWORIGINALIMPORTPANEL,false);		setChromBoolean(CHROMATOGRAMSONTOP,false);		setChromBoolean(SHOWMULTIREADCALLSPANEL,true);		setChromBoolean(SHOWOVERVIEWPANEL,true);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);		setChromBoolean(COLORIMPORTEDBYQUALITY,false);		setChromBoolean(COLORREADCALLSBYQUALITY,false);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,false);		setChromBoolean(THICKTRACE,false);		setChromBoolean(SHOWREADMATRIXCONFLICT,false);		setChromBoolean(SCROLLTOTOUCHED,true);	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		Snapshot fromWindow = super.getSnapshot(file);		snapshot.incorporate(fromWindow,false);		snapshot.addLine("showControls  " + showControls.toOffOnString());		snapshot.addLine("toggleShowA  " + showA.toOffOnString());		snapshot.addLine("toggleShowC " + showC.toOffOnString());		snapshot.addLine("toggleShowG " + showG.toOffOnString());		snapshot.addLine("toggleShowT " + showT.toOffOnString());				/*   removed from snapshot		snapshot.addLine("setFadeThreshold  " + chromInt[FADELOWQUALITYTHRESHOLD].getValue());		snapshot.addLine("setJumpQualityThreshold  " + chromInt[JUMPQUALITYTHRESHOLD].getValue());		snapshot.addLine("setJumpConflictThreshold  " + chromInt[JUMPCONFLICTTHRESHOLD].getValue());		snapshot.addLine("setDimConflictMarkerTheshold " + chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue()); 		snapshot.addLine("toggleFadeNonSourceLowerQualityRead  " + fadeNonSourceLowerQualityRead.toOffOnString());		snapshot.addLine("toggleUseSequencherColors  " + useSequencherColors.toOffOnString());		snapshot.addLine("toggleColorReadCallsByQuality  " + colorReadCallsByQuality.toOffOnString());		snapshot.addLine("toggleColorMultiReadByQuality  " + colorMultiReadByQuality.toOffOnString());		snapshot.addLine("toggleColorOverviewByQuality  " + colorOverviewByQuality.toOffOnString());		snapshot.addLine("toggleColorEditedInMatrixByQuality  " + colorEditedInMatrixByQuality.toOffOnString());		snapshot.addLine("toggleColorImportedByQuality  " + colorImportedByQuality.toOffOnString());		snapshot.addLine("toggleShowAceContigPanel " + showAceContigPanel.toOffOnString());		snapshot.addLine("toggleShowOriginalImportPanel " + showOriginalImportPanel.toOffOnString());		snapshot.addLine("toggleChromatogramsOnTop  " + chromatogramsOnTop.toOffOnString());		snapshot.addLine("toggleShowOverviewPanel " + showOverviewPanel.toOffOnString());		snapshot.addLine("toggleShowMultiReadCallsPanel " + showMultiReadCallsPanel.toOffOnString());		snapshot.addLine("toggleFixedChromatoHeight  " + fixedChromatoHeight.toOffOnString());		snapshot.addLine("toggleShowBaseSource " + chromDisplayBoolean[SHOWBASESOURCE].toOffOnString());		snapshot.addLine("toggleFadeNonSourceRead  " + chromDisplayBoolean[FADENONSOURCEREAD].toOffOnString());			snapshot.addLine("toggleThickTrace  " + thickTrace.toOffOnString());		snapshot.addLine("toggleShowChromMatrixDisagreement  " + showReadMatrixConflict.toOffOnString());		snapshot.addLine("toggleShowReadReadConflict  " + showReadReadConflict.toOffOnString());		snapshot.addLine("toggleShowLowerQualSourceConflictsWithHigherQualRead  " + showLowerQualSourceConflictsWithHigherQualRead.toOffOnString());		snapshot.addLine("toggleFades  " + showFades.toOffOnString());		snapshot.addLine("toggleFadeLowQuality  " + fadeLowQuality.toOffOnString());		snapshot.addLine("toggleShowReadName  " + showReadName.toOffOnString());		snapshot.addLine("toggleDimLowQualityConflicts  " + dimLowQualityConflicts.toOffOnString());		snapshot.addLine("toggleShowCodonPosition " + showCodonPosition.toOffOnString());		snapshot.addLine("toggleScrollToTouched " + chromBoolean[SCROLLTOTOUCHED].toOffOnString());		snapshot.addLine("turnOffEditOnMove " + chromBoolean[TURNOFFEDITONMOVE].toOffOnString());		snapshot.addLine("toggleJumpToNextBase " + chromBoolean[JUMPTONEXTBASE].toOffOnString());		snapshot.addLine("toggleJumpToNextConflict " + chromBoolean[JUMPTONEXTREADREADCONFLICT].toOffOnString());		snapshot.addLine("toggleJumpToNextReadMatrixConflict " + chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].toOffOnString());		snapshot.addLine("toggleJumpToNextLowQuality " + chromBoolean[JUMPTONEXTLOWQUALITY].toOffOnString());		snapshot.addLine("toggleJumpToNextAmbiguity " + chromBoolean[JUMPTONEXTAMBIGUITY].toOffOnString());		snapshot.addLine("toggleJumpToNextBadSource " + chromBoolean[JUMPTONEXTBADSOURCEREAD].toOffOnString());		snapshot.addLine("toggleIgnoreProblemIfBaseCalled " + chromBoolean[IGNOREPROBLEMIFBASECALLED].toOffOnString());	 */		snapshot.addLine("toggleShadowReduction " + enableShadowReduction.toOffOnString());		snapshot.addLine("showPrimerMatches " + showPrimerMatches.toOffOnString());		snapshot.addLine("useBTOLDatabase " + useBTOLDatabase.toOffOnString());		snapshot.addLine("showSinglePrimerMatch " + showSinglePrimerMatch.toOffOnString());		snapshot.addLine("setSinglePrimer  " + ParseUtil.tokenize(singlePrimer.getValue()));		snapshot.addLine("lockSequences " + sequencesLocked.toOffOnString());		Snapshot s = contigPanel.getSnapshot(file);		if (s != null){			snapshot.addLine("getMainContigPanel");			snapshot.addLine("tell It");			snapshot.incorporate(s, true);			snapshot.addLine("endTell");		}		if (extraContigs.size() > 0){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				Taxon taxon = p.getTaxon();				if (taxon != null){					int it = taxon.getNumber();					snapshot.addLine("showExtraContig " + it);					Snapshot sE = p.getSnapshot(file);					if (sE != null){						snapshot.addLine("tell It");						snapshot.incorporate(sE, true);						snapshot.addLine("endTell");					}				}			}		}		snapshot.addLine("scrollToOverallBase " + contigPanel.getCenterBase());		return snapshot;	}	/*.................................................................................................................*/	void initializeContigPanelSettings(ContigPanel p){		p.setShowA(showA.getValue());		p.setShowC(showC.getValue());		p.setShowG(showG.getValue());		p.setShowT(showT.getValue());		p.setScrollToTouched(chromBoolean[SCROLLTOTOUCHED].getValue());		p.setShowBaseSource(chromBoolean[SHOWBASESOURCE].getValue());		p.setShowCodonPosition(chromBoolean[SHOWCODONPOSITION].getValue());		p.setShowReadName(chromBoolean[SHOWREADNAME].getValue());		//	p.setShowBaseNumberWithinRead(showBaseNumberWithinRead.getValue());		p.setShowReadMatrixConflict(chromBoolean[SHOWREADMATRIXCONFLICT].getValue());		p.setShowReadReadConflict(chromBoolean[SHOWREADREADCONFLICT].getValue());		p.setShowLowerQualSourceConflictsWithHigherQualRead(chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD].getValue());		p.setDimConflictMarkerThreshold(chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue());		p.setDimLowQualityConflicts(chromBoolean[DIMLOWQUALITYCONFLICTS].getValue());		p.setFadeLowQuality(chromBoolean[FADELOWQUALITY].getValue());		p.setShowFades(chromBoolean[SHOWFADES].getValue());		p.setFadeNonSourceRead(chromBoolean[FADENONSOURCEREAD].getValue());		p.setFadeNonSourceLowerQualityRead(chromBoolean[FADENONSOURCELOWERQUALITYREADS].getValue());		p.setFadeQualityThreshold(chromInt[FADELOWQUALITYTHRESHOLD].getValue());		p.setShowAceContigPanel(chromBoolean[SHOWACECONTIGPANEL].getValue());		p.setShowMultiReadCallsPanel(chromBoolean[SHOWMULTIREADCALLSPANEL].getValue());		p.setShowOverviewPanel(chromBoolean[SHOWOVERVIEWPANEL].getValue());		p.setShowOriginalImportPanel(chromBoolean[SHOWORIGINALIMPORTPANEL].getValue());		p.setChromatogramsOnTop(chromBoolean[CHROMATOGRAMSONTOP].getValue());		p.setFixedChromatoHeight(chromBoolean[FIXEDCHROMATOHEIGHT].getValue());		p.setColorEditedInMatrixByQuality(chromBoolean[COLOREDITEDINMATRIXBYQUALITY].getValue());		p.setColorImportedByQuality(chromBoolean[COLORIMPORTEDBYQUALITY].getValue());		p.setColorReadByQuality(chromBoolean[COLORREADCALLSBYQUALITY].getValue());		p.setColorMultiReadByQuality(chromBoolean[COLORMULTIREADCALLSBYQUALITY].getValue());		p.setColorOverviewByQuality(chromBoolean[COLOROVERVIEWBYQUALITY].getValue());	}	/*.................................................................................................................*/	void addContig(Taxon taxon, Chromatogram[] chroms, Contig contig, Read[] reads){		ContigPanel panel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, false);		initializeContigPanelSettings(panel);		SequencePanel[] sequences = new SequencePanel[]{panel.aceContigPanel, panel.origSeqPanel, panel.matrixSeqPanel};		extraContigs.addElement(panel);		addToWindow(panel);		panel.setVisible(true);		ContigControlPanel control = new ContigControlPanel(taxon.getName(), panel);		ContigLinkerPanel linker = new ContigLinkerPanel(panel);		panel.setLinker(linker);		addToWindow(linker);		panel.setControl(control);		addToWindow(control);		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).addContext(taxon, contig, panel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, panel.getID());			}		}		sizeDisplays();	}	/*.................................................................................................................*/	void adjustChromInitsIfPositionChanges(){		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).adjustIfPositionChanges();			}		}	}	/*.................................................................................................................*/	void removeContig(ContigPanel panel){		extraContigs.removeElement(panel);		panel.setVisible(false);		ContigControlPanel control = panel.getControl();		control.setVisible(false);		removeFromWindow(panel);		removeFromWindow(control);		sizeDisplays();	}	/*.................................................................................................................*/	public boolean getChromatogramsOnTop() {		return chromBoolean[CHROMATOGRAMSONTOP].getValue();	}	/*.................................................................................................................*/	public static VChromWindow showChromatogram(Contig contig, MesquiteTable table, DNAData matrixData, Taxon taxon, VChromWindow existing, MesquiteModule windowServer, ChromatogramViewer ownerModule, String xmlPrefsString){		if (windowServer == null)			return null;		try {			int count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				if (!StringUtil.blank(contig.getRead(i).getABIFile()) && !StringUtil.blank(contig.getRead(i).getABIFilePath()))					count++;			}			if (count == 0)				return null;			String[] fileNames = new String[count];			String[] paths = new String[count];			Read[] reads = new Read[count];			count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				String abiFile = contig.getRead(i).getABIFile();				String abiFilePath = contig.getRead(i).getABIFilePath();				reads[count] = contig.getRead(i);				if (!StringUtil.blank(abiFile) && !StringUtil.blank(abiFilePath)) {					fileNames[count] = abiFile;					paths[count] = abiFilePath;					count++;				}			}			if (paths==null  || fileNames==null)				return null;			Chromatogram[] chromatograms = new Chromatogram[paths.length];			Associable as = matrixData.getTaxaInfo(false);			String[] fileNamesTranslator = null;			String[] primerNamesTranslator = null;			String[] sampleCodesTranslator = null;			if (as != null) {				fileNamesTranslator = ChromaseqUtil.getStringsAssociated(as,ChromaseqUtil.origReadFileNamesRef, taxon.getNumber());				primerNamesTranslator = ChromaseqUtil.getStringsAssociated(as,ChromaseqUtil.primerForEachReadNamesRef, taxon.getNumber());				sampleCodesTranslator = ChromaseqUtil.getStringsAssociated(as, ChromaseqUtil.sampleCodeNamesRef, taxon.getNumber());			}			for (int i = 0; i<paths.length; i++){ //getting chromatograms from all of the reads				File file = new File(paths[i].toString(), fileNames[i].toString());				FileInputStream regIN = new FileInputStream(file);;				BufferedInputStream fileIN = new BufferedInputStream(regIN);				byte[] magicNumArray = new byte[4];				fileIN.read(magicNumArray);				ByteArrayInputStream magicIN = new ByteArrayInputStream(magicNumArray);				DataInputStream magicDIN = new DataInputStream(magicIN);				int magicNum = magicDIN.readInt();				magicIN.reset();				SequenceInputStream seqIN = new SequenceInputStream(magicIN,fileIN);//				Debugg.println("fileName: " + fileNames[i].toString());				if (magicNum == ABIChromatogram.MagicNum) {					chromatograms[i] = new ABIChromatogram(seqIN,reads[i]);					}				else if (magicNum == SCFChromatogram.MagicNum) {					chromatograms[i] = new SCFChromatogram(seqIN, reads[i]);				}				else throw new IOException("Unknown file type");				if (chromatograms[i]!=null) {					String origName = findNameRefElement(fileNamesTranslator, fileNames[i]);					if (origName != null)						chromatograms[i].setTitle(origName.toString());					else						chromatograms[i].setTitle("Read " + (i+1));//					chromatograms[i].report("");					if (primerNamesTranslator!=null) {						String primerName = findNameRefElement(primerNamesTranslator, fileNames[i]);						reads[i].setPrimerName(primerName);   //DO NOT set this, as ther primer is now acquired later.					}					if (sampleCodesTranslator!=null) {						String sampleCodeSource = findNameRefElement(sampleCodesTranslator, fileNames[i], 1, 2);						String sampleCode = findNameRefElement(sampleCodesTranslator, fileNames[i], 2, 2);						reads[i].setSampleCode(sampleCode);   //DO NOT set this, as ther primer is now acquired later.						reads[i].setSampleCodeSource(sampleCodeSource);   //DO NOT set this, as ther primer is now acquired later.					}					if (reads[i].getComplemented())						chromatograms[i].reverseComplement(false);									}			}			if (existing == null){				ownerModule.hireAllEmployees(ChromInit.class);				VChromWindow cw = new VChromWindow(ownerModule, windowServer, table, matrixData, taxon,"Chromatograms: " + taxon.getName(), chromatograms, contig, reads, xmlPrefsString); 				windowServer.setModuleWindow(cw);				if (!MesquiteThread.isScripting())					cw.setVisible(true);				windowServer.resetContainingMenuBar();				MesquiteModule.resetAllWindowsMenus();				return cw;			}			else {				existing.addContig(taxon, chromatograms, contig, reads);				return existing;			}		}		catch (MalformedURLException ex) {			System.out.println("Malformed URL");		}		catch (IOException ex) {			String exMessage = ex.getMessage();			String exName = ex.getClass().getName();			System.out.println("IO ERROR: " + exName + " : " + exMessage);		}		return null;	}	/* ............................................................................................................... */	/** returns the current Hand cursor for dragging columns, etc. */	public Cursor getHandCursor() {		return handCursor;	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	 to be self-titling so that when things change (names of files, tree lists, etc.)	 they can reset their titles properly*/	public void resetTitle(){		setTitle(title);	}	public Taxon getTaxon(){		return contigPanel.getTaxon();	}	public void centerPanelAtOverallPosition(int ic){		contigPanel.centerPanelsAtOverallPosition(ic);	}	public int getHomePositionInMatrix(){		return contigPanel.getHomePositionInMatrix();	}	public int getCenterBase(){		return contigPanel.getCenterBase();		}	public void synchChromToTable(boolean synchPosition){		contigPanel.synchChromToTable(synchPosition);	}	public int getDisplayPositionOfMatrixPosition(int ic){		return contigPanel.getConsensusPositionOfMatrixPosition(ic);	}	public  void scrollToMatrixBase(int ic){		contigPanel.scrollToMatrixBase(ic);	}	public  void scrollToOverallBase(int ic){		contigPanel.scrollToOverallBase(ic);	}	public  void scrollToConsensusBase(int ic){		contigPanel.scrollToConsensusBase(ic);	}	public SequencePanel getSequencePanel(int whichPanel){		return contigPanel.getSequencePanel(whichPanel);	}	public  int getTotalNumPeaks(){		return contigPanel.getTotalNumOverallBases();	}	public  ContigDisplay getMainContigPanel(){		return contigPanel;	}	public boolean extraContigsShown() {		return extraContigs.size()>0;	}	public void scrollsChanged(ContigPanel panel, int center){		if (panel != null && extraContigs != null && extraContigs.size()>0 && sequencesLocked.getValue()){			if (panel == contigPanel){				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff = p.getRelativeLockPos();					//if (p.isShownReversed() != contigPanel.isShownReversed())					//	diff = -diff;					/*(diff = c*f - c1*f1;					diffB = cB*f - c1B*f1;					c1B*f1 = cB*f - diff;					c1B = (cB*f - diff)/f1;					 */					int cB = center;					if (contigPanel.isShownReversed())						cB = -cB;					int c1B = cB-diff;					if (p.isShownReversed())						c1B = -c1B;					// 	Debugg.println("GET diff " + diff);									p.centerPanelsAtOverallPosition(c1B, false, true);					//	Debugg.println("GET diff after  contigPanel.getCenterBase()" + contigPanel.getCenterBase() + " p.getCenterBase() " + + p.getCenterBase() + " difference " + (contigPanel.getCenterBase()-p.getCenterBase()));									ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}			else {				int diff = panel.getRelativeLockPos();				/*diff = c*f - c1*f1;				diffB = cB*f - c1B*f1;				cB = (diff + c1B*f1)/f;				 */				int c1B = center;				if (panel.isShownReversed())					c1B = -c1B;				int cB = c1B+diff;				if (contigPanel.isShownReversed())					cB = -cB;				//if (panel.isShownReversed() != contigPanel.isShownReversed())				//	diff = -diff;				//Debugg.println("diffB " + diff);								contigPanel.centerPanelsAtOverallPosition(cB, false, true);				if (contigPanel.isShownReversed())					cB = -cB;				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff2 = p.getRelativeLockPos();					int c1B2 = cB-diff2;					if (p.isShownReversed())						c1B2 = -c1B2;					p.centerPanelsAtOverallPosition(c1B2, false, true);					ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}		}		else if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				ContigLinkerPanel link = p.getLinker();				link.repaint();			}		}	}	/*--------------------------------------*/	final int linkerHeight = 24;	/* Resize the chromatogram area and other components.*/	public void sizeDisplays(){		if (contigPanel != null){			int numContigs = extraContigs.size() + 1;			int left = 0;			if (numContigs>1 || showControls.getValue())				left = 24;			int modtest = 1;			if (extraContigs.size() % 2 == 0)				modtest = 0;			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				p.setBounds(left, getHeight()/numContigs*i, getWidth()-left, getHeight()/numContigs-linkerHeight);				p.sizePanels();				ContigControlPanel c = p.getControl();				if (i  % 2 == modtest)					c.setBackground(Color.lightGray);				else 					c.setBackground(ColorDistribution.veryLightGray);				c.setBounds(0, getHeight()/numContigs*i, left, getHeight()/numContigs);				ContigLinkerPanel link = p.getLinker();				link.setBounds(left, getHeight()/numContigs*(i+1)-linkerHeight, getWidth()-left, linkerHeight);			}			contigPanel.setBounds(left,getHeight()-getHeight()/numContigs, getWidth()-left, getHeight()/numContigs);			contigPanel.sizePanels();			if (numContigs>1 || showControls.getValue()){				ContigControlPanel c = contigPanel.getControl();				if (c == null){					c = new ContigControlPanel(contigPanel.getTaxon().getName(), contigPanel);					contigPanel.setControl(c);					c.setVisible(true);					addToWindow(c);				}				c.setBounds(0, getHeight()-getHeight()/numContigs, left, getHeight()/numContigs);				c.repaint();				//c.setBackground(ColorDistribution.lightGreen);				}			contigPanel.requestFocusInWindow();		}	}	/* Resize the chromatogram area and other components.*/	public void dispose(){		super.dispose();		if (data != null)			data.removeListener(this);		if (originalData != null)			originalData.removeListener(this);		if (qualityData != null)			qualityData.removeListener(this);		if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				removeContig(p);				p.dispose();			}			extraContigs.removeAllElements();		}		if (contigPanel != null)			contigPanel.dispose();	}	/** passes which object changed, along with optional Notification object with details (e.g., code number (type of change) and integers (e.g. which character))*/	public void changed(Object caller, Object obj, Notification notification){		if (obj == data){			if (data.getTaxa().whichTaxonNumber(contigPanel.getTaxon())<0){				closeWindow();			}			else if (extraContigs != null)				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					if (data.getTaxa().whichTaxonNumber(p.getTaxon())<0)						removeContig(p);					p.dispose();				}		}	}	/** passes which object was disposed*/	public void disposing(Object obj){		if (obj == data || obj == qualityData)			closeWindow();	}	/** Asks whether it's ok to delete the object as far as the listener is concerned (e.g., is it in use?)*/	public boolean okToDispose(Object obj, int queryUser){		return true;	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setWindowSize(int w, int h){		super.setWindowSize(w,h);		sizeDisplays();	}	/*--------------------------------------*/	/* Called when the window has been resized, e.g. by user. <b>(overrides method of MesquiteWindow)</b>*/	public void windowResized(){		sizeDisplays();	}	public void setVisible(boolean v){		super.setVisible(v);		contigPanel.requestFocusInWindow();	}	ChromWindowPalette chromPalette;	protected ToolPalette makeToolPalette(){		MesquiteCommand sliderCommand = MesquiteModule.makeCommand("magnify", this);		MesquiteCommand shadowCommand = MesquiteModule.makeCommand("shadowOffset", this);		MesquiteCommand shadowRedCommand = MesquiteModule.makeCommand("shadowReduction", this);		chromPalette = new ChromWindowPalette(ownerModule, this, sliderCommand, shadowCommand, shadowRedCommand);		return chromPalette;	}	public DNAData getMatrixData(){		return data;	}	public DNAData getOriginalData(){		return originalData;	}	public ContinuousData getQualityData(){		return qualityData;	}	public boolean showPrimers(){		return showPrimerMatches.getValue();	}	public Color getBackgroundColor(){		return backgroundColor;	}	public boolean getShowSinglePrimerMatch(){		return showSinglePrimerMatch.getValue();	}	public boolean getIgnoreProblemIfBaseCalled() {		return chromBoolean[IGNOREPROBLEMIFBASECALLED].getValue();	}	public String getSinglePrimer(){		if (singlePrimer==null)			return "";		return singlePrimer.getValue();	}	/*.................................................................................................................*/	public void startPrimerShow(){		showPrimerMatches.setValue(true);		contigPanel.setUpPrimers();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setUpPrimers();		}	}	/*.................................................................................................................*/	public void redrawChromatPanels () {		contigPanel.repaintPanels();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.repaintPanels();		}	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Scrolls to overall base", "[base]", commandName, "scrollToOverallBase")) {			int it= MesquiteInteger.fromFirstToken(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(it))				scrollToOverallBase(it);		}		else if (checker.compare(this.getClass(), "Convert selected to gaps", null, commandName, "selectedToGaps")) {			contigPanel.selectedToGaps();		}		else if (checker.compare(this.getClass(), "Convert trimmable to gaps", null, commandName, "trimmableToGaps")) {			contigPanel.trimmableToGaps();		}		else if (checker.compare(this.getClass(), "Revert selected to called", null, commandName, "selectedToCalled")) {			contigPanel.selectedToRevert();		}		else if (checker.compare(this.getClass(), "Sets whether shading multiple sequences are locked", "[on; off]", commandName, "lockSequences")) {			sequencesLocked.toggleValue(new Parser().getFirstToken(arguments));			setSequencesLocked(sequencesLocked.getValue());		}		else if (checker.compare(this.getClass(), "Shows whether primer shown is the single specified primer", "[on; off]", commandName, "showSinglePrimerMatch")) {			showSinglePrimerMatch.toggleValue(new Parser().getFirstToken(arguments));			if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){				mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;				mod.setShowSinglePrimerMatch(showSinglePrimerMatch.getValue());			}			if (showPrimerMatches.getValue()) {				startPrimerShow();				if (!MesquiteThread.isScripting())					redrawChromatPanels();			}		}		else if (checker.compare(this.getClass(), "Sets the single primer", "[primer name]", commandName, "setSInglePrimer")) {			String primerName =  new Parser().getFirstToken(arguments);			boolean success = true;			if (StringUtil.blank(primerName) && !MesquiteThread.isScripting()) {				if (singlePrimer==null)					singlePrimer = new MesquiteString("");				success = QueryDialogs.queryShortString(viewModule.containerOfModule(),"Primer Name", "Name of primer to display", singlePrimer);			}			else				singlePrimer.setValue(new Parser().getFirstToken(arguments));			if (success) {				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setSinglePrimer(singlePrimer.getValue());				}				if (showPrimerMatches.getValue())					startPrimerShow();			}		}		else if (checker.compare(this.getClass(), "Shows whether primers are shown matched", "[on; off]", commandName, "showPrimerMatches")) {			showPrimerMatches.toggleValue(new Parser().getFirstToken(arguments));			if (showPrimerMatches.getValue()){				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setShowPrimers(showPrimerMatches.getValue());				}				startPrimerShow();			}			else if (!MesquiteThread.isScripting())				redrawChromatPanels();		}		else if (checker.compare(this.getClass(), "Shows whether primer info comes from BTOL Database", "[on; off]", commandName, "useBTOLDatabase")) {			boolean currentValue = useBTOLDatabase.getValue();			useBTOLDatabase.toggleValue(new Parser().getFirstToken(arguments));			if (currentValue!=useBTOLDatabase.getValue()){				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setPrimerInfoFromDatabase(useBTOLDatabase.getValue());				}				if (showPrimerMatches.getValue()){					contigPanel.setUpPrimers();					for (int i = 0; i< extraContigs.size(); i++){						ContigPanel p = (ContigPanel)extraContigs.elementAt(i);						p.setUpPrimers();					}				}			}			if (!MesquiteThread.isScripting())				redrawChromatPanels();		}		else if (checker.compare(this.getClass(), "Set Primer Sequence File...", null, commandName, "setPrimerSequenceFile")) {			if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){				mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;				mod.resetPrimersFile();				if (showPrimerMatches.getValue()){					contigPanel.setUpPrimers();					for (int i = 0; i< extraContigs.size(); i++){						ContigPanel p = (ContigPanel)extraContigs.elementAt(i);						p.setUpPrimers();					}				}			}		}		else if (checker.compare(this.getClass(), "Returns main contig panel", null, commandName, "getMainContigPanel")) {			return contigPanel;		}		else if (checker.compare(this.getClass(), "Shows extra contig (taxon, sequence)", "[number of taxon]", commandName, "showExtraContig")) {			if (data != null){				Taxon taxon = null;				MesquiteInteger pos = new MesquiteInteger(0);				int it= MesquiteInteger.fromFirstToken(arguments, pos);				if (!MesquiteInteger.isCombinable(it)){					if (MesquiteThread.isScripting())						return null;					taxon = data.getTaxa().userChooseTaxon(this, "Choose extra sequence to show");					if (taxon == null)						return null;					it = data.getTaxa().whichTaxonNumber(taxon);				}				else taxon = data.getTaxa().getTaxon(it);				Associable tInfo = data.getTaxaInfo(false);				if (tInfo == null)					return null;				/*				String path = null;				if (tInfo == null)					return null;				path = (String)tInfo.get AssociatedObject(aceRef, it);//if Used call ChromaseqUtil.getStringAssociated				if (StringUtil.blank(path))					return null;				path = MesquiteFile.composePath(ownerModule.getProject().getHomeFile().getDirectoryName(), path);				if (!MesquiteFile.fileExists(path))					return null;				 */				AceFile ace = AceFile.getAceFile(ownerModule, data, it);				long whichContig = ChromaseqUtil.getLongAssociated(tInfo,ChromaseqUtil.whichContigRef, it);				this.table = (CMTable)table;				this.data = (DNAData)data;				if (whichContig < 0 || whichContig >= ace.getNumContigs())					return null;				VChromWindow.showChromatogram(ace.getContig((int)whichContig), table, data,  taxon, this, windowServer, (ChromatogramViewer)ownerModule, xmlPrefsString);				return extraContigs.elementAt(extraContigs.size()-1);			}		}		else if (checker.compare(this.getClass(), "Shadow offset chromatograms", null, commandName, "shadowOffset")) {			MesquiteInteger io = new MesquiteInteger(0);			double x = MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				int os = (int)((x-2.5)*20);				contigPanel.setShadowOffset(os);			}		}		else if (checker.compare(this.getClass(), "Shadow reduction chromatograms", null, commandName, "shadowReduction")) {			MesquiteInteger io = new MesquiteInteger(0);			double x= MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				contigPanel.setShadowReduction(x);			}		}		else if (checker.compare(this.getClass(), "Magnify chromatograms", null, commandName, "magnify")) {			MesquiteInteger io = new MesquiteInteger(0);			double x= MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				contigPanel.setMagnification(3.0 - x/2);				/*(3 - x/2)				 0 -- 3.0				 1-- 2.5				 2 --  2				 3 -- 1.5				 4-- 1.0				 5-- 0.5*/			}		}		else if (checker.compare(this.getClass(), "Touched with arrow.", null, commandName, "arrowTouch")) {		}		else if (checker.compare(this.getClass(), "Sets the threshold below which low quality bases will be faded", "[fadeLowQualityThreshold]", commandName, "setFadeThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Fading Threshold", "Threshold for fading low quality bases:", chromInt[FADELOWQUALITYTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[FADELOWQUALITYTHRESHOLD].getValue()) {				setChromInt(FADELOWQUALITYTHRESHOLD,newNum);				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between low quality bases", "[jumpQualityThreshold]", commandName, "setJumpQualityThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Option or Alt key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";			help += " sequence of quality less than the jump quality threshold value.  The jump quality threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Quality Threshold", "Jump between bases with quality less than:", help, chromInt[JUMPQUALITYTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[JUMPQUALITYTHRESHOLD].getValue()) {				setChromInt(JUMPQUALITYTHRESHOLD,newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between bases with conflicting reads", "[jumpConflictThreshold]", commandName, "setJumpConflictThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Control key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Phred.Phrap.Mesquite ";			help += " sequence in which two reads, both of quality greater than or equal to the jump conflict threshold value, differ in their calls.  The jump conflict threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Conflict Threshold", "Jump between bases with conflict quality greater than:", help, chromInt[JUMPCONFLICTTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[JUMPCONFLICTTHRESHOLD].getValue()) {				setChromInt(JUMPCONFLICTTHRESHOLD,newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold below conflcits will be dimmed", "[dimConflictMarkerThreshold]", commandName, "setDimConflictMarkerTheshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Dimming Threshold", "Quality threshold for dimming conflicts:", chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue()) {				setChromInt(DIMCONFLICTMARKERTHRESHOLD,newNum);				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets whether control bar is shown", "[on; off]", commandName, "showControls")) {			showControls.toggleValue(new Parser().getFirstToken(arguments));			sizeDisplays();		}		else if (checker.compare(this.getClass(), "Sets to standard style", "[none]", commandName, "styleStandard")) {			setToStandardStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that Bets likes.", "[none]", commandName, "stylePhoenix")) {			setToAEAStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that David likes.", "[none]", commandName, "styleCorvallis")) {			setToDRMStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that Wayne likes.", "[none]", commandName, "styleVancouver")) {			setToWPMStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for each read are colored by quality scores", "[on; off]", commandName, "toggleColorReadCallsByQuality")) {			setChromBoolean(COLORREADCALLSBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for the multiread panel are colored by quality scores", "[on; off]", commandName, "toggleColorMultiReadByQuality")) {			setChromBoolean(COLORMULTIREADCALLSBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for the overview panel are colored by quality scores", "[on; off]", commandName, "toggleColorOverviewByQuality")) {			setChromBoolean(COLOROVERVIEWBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases in Edited in Matrix line are colored by quality scores", "[on; off]", commandName, "toggleColorEditedInMatrixByQuality")) {			setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorImportedByQuality")) {			setChromBoolean(COLORIMPORTEDBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorByQuality")) {  // save as toggleColorImportedByQuality, here to support older scripts			setChromBoolean(COLORIMPORTEDBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the original, untrimmed sequence direclty from Phred/Phrap/Mesquite is shown", "[on; off]", commandName, "toggleShowAceContigPanel")) {			setChromBoolean(SHOWACECONTIGPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the multi read panel is shown", "[on; off]", commandName, "toggleShowMultiReadCallsPanel")) {			setChromBoolean(SHOWMULTIREADCALLSPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the overview panel is shown", "[on; off]", commandName, "toggleShowOverviewPanel")) {			setChromBoolean(SHOWOVERVIEWPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the original trimmed imported sequence is shown", "[on; off]", commandName, "toggleShowOriginalImportPanel")) {			setChromBoolean(SHOWORIGINALIMPORTPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether Chromatograms are on top or not", "[on; off]", commandName, "toggleChromatogramsOnTop")) {			setChromBoolean(CHROMATOGRAMSONTOP,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether Chromatograms are on top or not", "[on; off]", commandName, "toggleFixedChromatoHeight")) {			setChromBoolean(FIXEDCHROMATOHEIGHT,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the trace is shown using thick lines", "[on; off]", commandName, "toggleThickTrace")) {			setChromBoolean(THICKTRACE,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the trace is shown using sequencher colors", "[on; off]", commandName, "toggleUseSequencherColors")) {			setChromBoolean(USESEQUENCHERCOLORS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of low quality", "[on; off]", commandName, "toggleFadeLowQuality")) {			setChromBoolean(FADELOWQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether any fades are shown", "[on; off]", commandName, "toggleFades")) {			setChromBoolean(SHOWFADES,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source", "[on; off]", commandName, "toggleFadeNonSourceRead")) {			setChromBoolean(FADENONSOURCEREAD,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source AND of lower quality than the source", "[on; off]", commandName, "toggleFadeNonSourceLowerQualityRead")) {			setChromBoolean(FADENONSOURCELOWERQUALITYREADS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether shading indicates whether a chromatogram's call is different from matrix state", "[on; off]", commandName, "toggleShowChromMatrixDisagreement")) {			setChromBoolean(SHOWREADMATRIXCONFLICT,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bar indicates whether there are differences among the Phred calls for each read.", "[on; off]", commandName, "toggleShowReadReadConflict")) {			setChromBoolean(SHOWREADREADCONFLICT,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether to draw a box around the Phred calls for which the a lower quality read is the source and this conflicts with a higher quality read.", "[on; off]", commandName, "toggleShowLowerQualSourceConflictsWithHigherQualRead")) {			setChromBoolean(SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the name of the read is shown", "[on; off]", commandName, "toggleShowReadName")) {			setChromBoolean(SHOWREADNAME,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the red boxes for low quality conflicts are dimmed below the bases in the Phred.Phrap.Mesquite listing", "[on; off]", commandName, "toggleDimLowQualityConflicts")) {			setChromBoolean(DIMLOWQUALITYCONFLICTS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether shadow reduction is enabled", "[on; off]", commandName, "toggleShadowReduction")) {			enableShadowReduction.toggleValue(new Parser().getFirstToken(arguments));			chromPalette.setShadowSlidersVisible(enableShadowReduction.getValue());			contigPanel.setShadowOffset(0);			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the view is the overview", "[on; off]", commandName, "toggleViewOverview")) {		}		else if (checker.compare(this.getClass(), "Sets whether the view is the chromatogram view", "[on; off]", commandName, "toggleViewChromatograms")) {		}		//=======================================		else if (checker.compare(this.getClass(), "Sets whether the A trace is shown", "[on; off]", commandName, "toggleShowA")) {			showA.toggleValue(new Parser().getFirstToken(arguments));			setShowA(showA.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the C trace is shown", "[on; off]", commandName, "toggleShowC")) {			showC.toggleValue(new Parser().getFirstToken(arguments));			setShowC(showC.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the G trace is shown", "[on; off]", commandName, "toggleShowG")) {			showG.toggleValue(new Parser().getFirstToken(arguments));			setShowG(showG.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the T trace is shown", "[on; off]", commandName, "toggleShowT")) {			showT.toggleValue(new Parser().getFirstToken(arguments));			setShowT(showT.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether touching on the chromatograms centers the view to that base", "[on; off]", commandName, "toggleScrollToTouched")) {			setChromBoolean(SCROLLTOTOUCHED,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether single selected bases are deselected when the chromatogram panels are scrolled", "[on; off]", commandName, "toggleTurnOffEditOnMove")) {			setChromBoolean(TURNOFFEDITONMOVE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether single selected bases are deselected when the chromatogram panels are scrolled", "[on; off]", commandName, "turnOffEditOnMove")) {			setChromBoolean(TURNOFFEDITONMOVE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the source of the base (that is, the read Phrap chose as the primary one fro that base) is marked by a brown bar", "[on; off]", commandName, "toggleShowBaseSource")) {			setChromBoolean(SHOWBASESOURCE,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the codon position of a base is indicated by color", "[on; off]", commandName, "toggleShowCodonPosition")) {			setChromBoolean(SHOWCODONPOSITION,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next problem base", "[on; off]", commandName, "toggleJumpToNextBadSource")) {			setChromBoolean(JUMPTONEXTBADSOURCEREAD,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next base", "[on; off]", commandName, "toggleJumpToNextBase")) {			setChromBoolean(JUMPTONEXTBASE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next low quality base", "[on; off]", commandName, "toggleJumpToNextLowQuality")) {			setChromBoolean(JUMPTONEXTLOWQUALITY,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys ignore problems if the base has already been called", "[on; off]", commandName, "toggleIgnoreProblemIfBaseCalled")) {			setChromBoolean(IGNOREPROBLEMIFBASECALLED,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-read conflict", "[on; off]", commandName, "toggleJumpToNextConflict")) {			setChromBoolean(JUMPTONEXTREADREADCONFLICT,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-matrix conflict", "[on; off]", commandName, "toggleJumpToNextReadMatrixConflict")) {			setChromBoolean(JUMPTONEXTREADMATRIXCONFLICT,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next matrix value with an IUPAC ambiguity code", "[on; off]", commandName, "toggleJumpToNextAmbiguity")) {			setChromBoolean(JUMPTONEXTAMBIGUITY,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Shows the matrix", null, commandName, "showMatrix")) {			MesquiteWindow f = ownerModule.getEmployer().containerOfModule();			if (f!= null)				f.show();		}		else if (checker.compare(this.getClass(), "Saves current settings as defaults", "[none]", commandName, "saveDefaults")) {			viewModule.storePreferences();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	private void setShowA(boolean show){		contigPanel.setShowA(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowA(show);		}	}	private void setShowC(boolean show){		contigPanel.setShowC(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowC(show);		}	}	private void setShowG(boolean show){		contigPanel.setShowG(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowG(show);		}	}	private void setShowT(boolean show){		contigPanel.setShowT(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowT(show);		}	}	public void setScrollToTouched(boolean s){		contigPanel.setScrollToTouched(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setScrollToTouched(s);		}	}//	public void setTurnOffEditOnMove(boolean s){//	}	public void setShowBaseSource(boolean s){		contigPanel.setShowBaseSource(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseSource(s);		}	}	public void setShowCodonPosition(boolean s){		contigPanel.setShowCodonPosition(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowCodonPosition(s);		}	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		contigPanel.setShowReadName(showReadName);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadName(showReadName);		}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		contigPanel.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		BasicChromatogramPanel.SHOWREADMATRIXCONFLICTDEFAULT = show;		contigPanel.setShowReadMatrixConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadMatrixConflict(show);		}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		contigPanel.setShowReadReadConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadReadConflict(show);		}	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		contigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowLowerQualSourceConflictsWithHigherQualRead(show);		}	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		contigPanel.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		contigPanel.setDimLowQualityConflicts(dimLowQualityConflicts);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimLowQualityConflicts(dimLowQualityConflicts);		}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		contigPanel.setFadeLowQuality(fadeLowQuality);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeLowQuality(fadeLowQuality);		}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		contigPanel.setShowFades(showFades);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowFades(showFades);		}		if (showFadesMenuItem!=null) {			if (showFades)				showFadesMenuItem.setName("Don't Show Fades");			else				showFadesMenuItem.setName("Show Fades");			ownerModule.resetContainingMenuBar();		}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		contigPanel.setFadeNonSourceRead(fadeNonSourceRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceRead(fadeNonSourceRead);		}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		contigPanel.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		contigPanel.setFadeQualityThreshold(fadeQualityThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeQualityThreshold(fadeQualityThreshold);		}	}	/*.................................................................................................................*/	public void setSequencesLocked(boolean seqLocked) {		contigPanel.setSequencesLocked(seqLocked);		int centerMain = contigPanel.getCenterBase();		if (contigPanel.isShownReversed())			centerMain = -centerMain;		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setSequencesLocked(seqLocked);			int centerThis = p.getCenterBase();			if (p.isShownReversed())				centerThis = -centerThis;			int diff = centerMain - centerThis;			//	Debugg.println("SET diff " + diff);			p.setRelativeLockPos(diff);		}	}	/*.................................................................................................................*/	public void setColorImportedByQuality(boolean cbQ) {		contigPanel.setColorImportedByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorReadCallsByQuality(boolean cbQ) {		contigPanel.setColorReadByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorMultiReadByQuality(boolean cbQ) {		contigPanel.setColorMultiReadByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorOverviewByQuality(boolean cbQ) {		contigPanel.setColorOverviewByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorEditedInMatrixByQuality(boolean cbQ) {		contigPanel.setColorEditedInMatrixByQuality(cbQ);	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		contigPanel.setThickTrace(thickTrace);	}	/*.................................................................................................................*/	public void setUseSequencherColors(boolean useSequencherColors)  {		contigPanel.setUseSequencherColors(useSequencherColors);	}	/*.................................................................................................................*/	public boolean getUseSequencherColors()  {		return chromBoolean[USESEQUENCHERCOLORS].getValue();	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*2+1<namesTranslator.length; i++){			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*2]))				return namesTranslator[i*2+1];		}		return changedName;	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName, int whichElement, int numElements){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*(numElements+1)+whichElement<namesTranslator.length; i++){   //DavidJan07: OK?			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*(numElements+1)]))				return namesTranslator[i*(numElements+1)+whichElement];		}		return changedName;	}}class ContigLinkerPanel extends MesquitePanel implements SequenceMatchCalc{	ContigPanel parent, otherPanel;	MatrixSequence mySeq, refSeq;	String mySequence, otherSequence;	SequenceCanvas mySeqCanvas, refSeqCanvas;	Color[] match;	public ContigLinkerPanel(ContigPanel parent){		this.parent = parent;		SequencePanel mySeqPanel = parent.getSequencePanel(2);		otherPanel = (ContigPanel)parent.window.getMainContigPanel();		SequencePanel refSeqPanel = otherPanel.getSequencePanel(2);		refSeqCanvas = refSeqPanel.getCanvas();		mySeq = (MatrixSequence)mySeqPanel.getSequence();		mySeqCanvas = mySeqPanel.getCanvas();		refSeq = (MatrixSequence)refSeqPanel.getSequence();		//setBackground(Color.blue);	}	double compareStates(char char1, char char2){		long state = DNAState.fromCharStatic(char1);		long state2 = DNAState.fromCharStatic(char2);		int cardInt = CategoricalState.cardinality(state & state2);		int cardUn = CategoricalState.cardinality(state | state2);		if (cardUn == 0)			return 0;		return (cardInt*1.0/cardUn);	}	int distance = 8;	int widthHalf = 20;	public synchronized Color getBaseMatchColor(int ic){		int diff = otherCenter-center;		double s = 0;		if (parent.isShownReversed())			ic = mySequence.length() - ic;		String acO = "";		String ac = "";		//looking at a window widthHalf left and right of this site		for (int ik = ic-widthHalf; ik<= ic + widthHalf; ik++){ //surveying window			//seeing that point in window is in both sequences			if (ik>=0 && ik<mySequence.length() && ik+diff>=0 && ik+diff<otherSequence.length()){				char state = mySequence.charAt(ik);				char otherState = otherSequence.charAt(ik+diff);				if (ic == center){					ac += state;					acO += otherState;				}				s += compareStates(state, otherState);			}		}		s = s/(2.0*widthHalf +1);		double bestScore = s;  //set this as baseline best match		int bestOffset = 0;		for (int offset= -distance; offset<=distance; offset++){			int icOffset = ic + offset;			if (icOffset>=0 && icOffset<mySequence.length()){				double sD = 0;				//looking at a window widthHalf left and right of this site				for (int ik = icOffset-widthHalf; ik<= icOffset + widthHalf; ik++){ //surveying window					//seeing that point in window is in both sequences					if (ik>=0 && ik<mySequence.length() && ik+diff-offset>=0 && ik+diff-offset<otherSequence.length()){						char state = mySequence.charAt(ik);						char otherState = otherSequence.charAt(ik+diff- offset);						sD += compareStates(state, otherState);					}				}				sD = sD/(2.0*widthHalf +1);				if (sD > bestScore) {					bestScore = sD;					bestOffset = offset;				}			}		}		//bestScore = bestScore*0.7;//to soften colors		if (bestOffset>0){			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset =1;			return MesquiteColorTable.getGreenScale(bestScore/bestOffset, 0, 1, false);		}		else if (bestOffset<0){			bestOffset = - bestOffset;			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset = 1;			return MesquiteColorTable.getRedScale(bestScore/bestOffset, 0, 1, false);		}		else {			if (ic>=0 && ic<mySequence.length() && ic+diff>=0 && ic+diff<otherSequence.length()){				char state = mySequence.charAt(ic);				char otherState = otherSequence.charAt(ic+diff);				if (state == otherState){					double score = compareStates(state, otherState);					if (score > 0.9){						//if (CategoricalState.cardinality(DNAState.fromCharStatic(state))>1 || CategoricalState.cardinality(DNAState.fromCharStatic(otherState))>1){						//	Debugg.println("state " + CategoricalState.toString(DNAState.fromCharStatic(state)) + " otherState " + CategoricalState.toString(DNAState.fromCharStatic(otherState)) + " score " + score);						//}						return Color.yellow;					}				}			}			return MesquiteColorTable.getYellowScale(bestScore, 0, 2, false);		}	}	int center, otherCenter; //myLength, otherLength, 	public void paint(Graphics g){		//myLength = mySeq.getLength();		//otherLength = refSeq.getLength();		center = mySeqCanvas.getLocalIndexFromConsensus(parent.getContigBaseFromUniversalBase(parent.getCenterBase()));		otherCenter = refSeqCanvas.getLocalIndexFromConsensus(otherPanel.getContigBaseFromUniversalBase(otherPanel.getCenterBase()));		mySequence = mySeq.getSequence();		otherSequence = refSeq.getSequence();		//	Debugg.println("mySequence " + center + "  " + otherCenter);		if (parent.isShownComplemented())			mySequence = DNAData.complementString(mySequence);		if (parent.isShownReversed()){			mySequence = DNAData.reverseString(mySequence);			center = mySequence.length()-center;		}		/**/		/**/		//	Debugg.println("mySequenceLATER " + center + "  " + otherCenter);		if (otherPanel.isShownComplemented())			otherSequence = DNAData.complementString(otherSequence);		if (otherPanel.isShownReversed()){			otherSequence = DNAData.reverseString(otherSequence);			otherCenter = otherSequence.length()-otherCenter;		}		mySequence = mySequence.toLowerCase();		otherSequence = otherSequence.toLowerCase();//		COMPLEMENT IF NEEDED//		REVERSE IF NEEDED AND then change center		g.translate(0, -14);		mySeqCanvas.paint(g, true, this);		g.translate(0, 14);		g.setColor(Color.black);		g.fillRect(0, getBounds().height-3, getBounds().width, 3);	}}class ContigControlPanel extends MesquitePanel  {	//close (all except for base)	//close individual reads	// reverse	// complement	// name	String name;	ContigPanel parent;	MesquiteButton reverseButton, complementButton, goAwayButton;	MesquiteButton[] chromatButtons=null;	boolean showChromatButtons = false;	boolean isPrimary;	public ContigControlPanel(String name, ContigPanel parent){		this.name = name;		this.parent = parent;		this.isPrimary = parent.isPrimary;		if (showChromatButtons) {			chromatButtons = new MesquiteButton[parent.getNumChromats()];			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i] = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("toggleChromatVisible", parent), Integer.toString(i), true, parent.window.viewModule.getPath() + "triangleDownOn.gif", 12, 12);				chromatButtons[i].setOptionImagePath(parent.window.viewModule.getPath() + "triangleRightOn.gif");				add(chromatButtons[i]);				chromatButtons[i].setBounds(getBounds().width-20, parent.getChromatTop(i), 12, 12);				chromatButtons[i].setShowBackground(false);				chromatButtons[i].setVisible(true);				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));			}		}		int top = getBounds().height-36;		complementButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showComplemented", parent), null, true, parent.window.viewModule.getPath() + "complementOff.gif", 16, 16);		complementButton.setOptionImagePath(parent.window.viewModule.getPath() + "complementOn.gif");		add(complementButton);		complementButton.setBounds(4, top, 16, 16);		top -= 20;		complementButton.setShowBackground(false);		complementButton.setVisible(true);		complementButton.setOptionDown(parent.showComplemented.getValue());		reverseButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showReversed", parent), null, true, parent.window.viewModule.getPath() + "forward.gif", 16, 16);		reverseButton.setOptionImagePath(parent.window.viewModule.getPath() + "reverse.gif");		add(reverseButton);		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setShowBackground(false);		reverseButton.setVisible(true);		reverseButton.setOptionDown(parent.showReversed.getValue());		if (!isPrimary){			goAwayButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("goAway", parent), null, true, MesquiteModule.getRootImageDirectoryPath() + "goAway.gif", 16, 16);			add(goAwayButton);			goAwayButton.setBounds(4, top, 16, 16);			goAwayButton.setShowBackground(false);			goAwayButton.setVisible(true);		}	}	void resetButtons(){		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));				chromatButtons[i].repaint();			}		}	}	void resize(){		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));				chromatButtons[i].setBounds(getBounds().width-16, parent.getChromatTop(i) +2, 12, 12);				chromatButtons[i].repaint();			}		}		int top = getBounds().height-36;		complementButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		if (!isPrimary){			goAwayButton.setBounds(2, top, 16, 16);		}	}	public void setSize(int w, int h){		super.setSize( w,  h);		resize();	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x, y, w,  h);		resize();	}	public void setBackground(Color c){		super.setBackground(c);		if (goAwayButton != null)			goAwayButton.setBackground(c);		complementButton.setBackground(c);		reverseButton.setBackground(c);		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setBackground(c);			}		}	}	public void paint(Graphics g){		setBackground(ColorTheme.getContentBackground());		g.setColor(ColorTheme.getInterfaceEdgePositive());		g.drawRect(0,0,getBounds().width-1, getBounds().height);		//g.drawRect(1,1,getBounds().width-3, getBounds().height-3);	}}/* ======================================================================== */class ChromWindowPalette extends ToolPalette {	VChromWindow w;	MiniSlider magSlider, shadowSlider, shadowRedSlider;	int shadowWidth = 40;	public ChromWindowPalette(MesquiteModule ownerModule, VChromWindow containingWindow, MesquiteCommand sliderCommand, MesquiteCommand shadowOffsetCommand, MesquiteCommand shadowRedCommand) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 1);		w = containingWindow;		magSlider = new MiniSlider (sliderCommand, false, 4, 0, 5, 0, 5);		add(magSlider);		magSlider.setVisible(true);		magSlider.setBounds(20, 100, 10, 200);		shadowSlider = new MiniSlider (shadowOffsetCommand, true, 2.5, 0, 5, 0, 5);		add(shadowSlider);		shadowSlider.setVisible(false);		shadowSlider.setBounds(20, 40, shadowWidth, 12);		shadowRedSlider = new MiniSlider (shadowRedCommand, false, 0.5, 0, 1, 0, 1);		add(shadowRedSlider);		shadowRedSlider.setVisible(false);		shadowRedSlider.setBounds(20, 60, shadowWidth, 12);	}	public void setShadowSlidersVisible(boolean vis){		shadowSlider.setVisible(vis);		shadowRedSlider.setVisible(vis);	}	public void setSize(int width, int height){		super.setSize(width, height);		magSlider.setSize(16, 80);		magSlider.setLocation(width/2-10, height-100);		shadowSlider.setSize(shadowWidth, 16);		shadowSlider.setLocation(width/2-shadowWidth/2, height-180);		shadowRedSlider.setSize(16, shadowWidth);		shadowRedSlider.setLocation(width/2-8, height-160);	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		magSlider.setSize(16, 80);		magSlider.setLocation(width/2-10, height-100);		shadowSlider.setSize(shadowWidth, 16);		shadowSlider.setLocation(width/2-shadowWidth/2, height-180);		shadowRedSlider.setSize(16, shadowWidth);		shadowRedSlider.setLocation(width/2-8, height-160);	}		}/*class SequenceIterator {	MatrixSequence seq;	MolecularData data;	MesquiteInteger currentMatrixIC, currentSeqIC;	MesquiteBoolean firstHit = new MesquiteBoolean(false);	public SequenceIterator(MolecularData data, MatrixSequence seq){		this.data = data;		this.seq = seq;		currentMatrixIC = new MesquiteInteger(0);		currentSeqIC = new MesquiteInteger(0);	}	public void reset(){		firstHit.setValue(false);		currentMatrixIC.setValue(0);		currentSeqIC.setValue(0);	}	public long getSite(int ic, boolean verb){if (verb)	Debugg.println("target " + ic + "  currentSeqIC " + currentSeqIC + "  currentMatrixIC " + currentMatrixIC + "  firstHit " + firstHit);			if (ic >= currentSeqIC.getValue())			return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 		reset();		return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 	}} *//*class PrefBoolean extends MesquiteBoolean {	static boolean factoryDefaultValue = true;	static boolean defaultValue = true;	public PrefBoolean (boolean factoryDefault, boolean startValue) {		super(startValue);		defaultValue = startValue		factoryDefaultValue=factoryDefault;	}	public void setFactoryDefault(boolean b) {		factoryDefaultValue = b;	}	public void returnToFactoryDefault() {		setValue(factoryDefaultValue);	}	public void setValue(boolean b) {		super.setValue(b);		defaultValue=b;	}} *///^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^class ContigPanel extends MesquitePanel implements ContigDisplay, AdjustmentListener, ClosablePanelContainer {	static boolean listen = true; //static because all windows need to stop listening momentarily	int numBasesOriginallyTrimmedFromStartOfPhPhContig = -1;	int padBeforeTrim = -1;	int minimumChromatoHeight=0;	double horizScale = 1.0;	double peakDistance = 20.0;	int centerBase = 0;	MatrixSequence originalSequence;	MatrixSequence editedSequence;	Panel chromSetPanel;	BasicChromatogramPanel[] chromPanels;	Chromatogram[] chromatograms;	SequencePanel aceContigPanel;	SequencePanel matrixSeqPanel;	SequencePanel origSeqPanel;	MultiReadCallsPanel multiReadCallsPanel;	ContigOverviewPanel overviewPanel;	Contig contig;	Taxon taxon;	String sequenceID = null;	int seqPanelHeight = 36;	int scrollDepth = 16;	int bufferHeight = 4;	Panel bufferPanel;	int numSequencePanels = 3;	int spacer = 4;	boolean[] selectedUniversalBase=null;		ChromaseqUniversalMapper universalMapper;	boolean showAceContigPanel = false;	boolean showOriginalImportPanel = true;;	boolean chromatogramsOnTop = false;	boolean showOverviewPanel = false;	static int standardChromatoHeight = 120;	boolean showMultiReadCallsPanel = false;	boolean fixedChromatoHeight = true;	int vertScrollPosition = 0;	int maxVertScroll=0;	ChromaseqBaseMapper chromMapper;	ContigControlPanel control;	ContigLinkerPanel linker;	Scrollbar horizScrollBar;	Scrollbar vertScrollBar;	MesquitePanel horizScrollPanel;	MesquitePanel vertScrollPanel;	VChromWindow window;	DNAData data;	DNAData originalData;	ContinuousData qualityData;	MesquiteTable table;	MesquiteBoolean showComplemented = new MesquiteBoolean(false);	MesquiteBoolean showReversed = new MesquiteBoolean(false);	boolean isPrimary = false;	boolean locked = false;	static int numIDs = 0;	int id;	public ContigPanel (VChromWindow window, DNAData data, DNAData originalData, ContinuousData qualityData, MesquiteTable table, Taxon taxon, Chromatogram[] chroms, Contig contig, boolean isPrimary){		//^^^^single contig^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		this.taxon = taxon;		id = ++numIDs;		this.contig = contig;		this.isPrimary = isPrimary;		chromatograms = chroms;		double totalPeakDistance = 0.0;		this.data = data;		chromMapper = new ChromaseqBaseMapper(data);		this.originalData = originalData;		this.qualityData = qualityData;		this.window = window;		this.table = table;		addKeyListener(this);		requestFocusInWindow();		showAceContigPanel = window.defaultChromBoolean[window.SHOWACECONTIGPANEL];		showMultiReadCallsPanel = window.defaultChromBoolean[window.SHOWMULTIREADCALLSPANEL];		showOverviewPanel = window.defaultChromBoolean[window.SHOWOVERVIEWPANEL];		showOriginalImportPanel = window.defaultChromBoolean[window.SHOWORIGINALIMPORTPANEL];		chromatogramsOnTop = window.defaultChromBoolean[window.CHROMATOGRAMSONTOP];		fixedChromatoHeight = window.defaultChromBoolean[window.FIXEDCHROMATOHEIGHT];		setNumBasesAddedToStart(ChromaseqUtil.getNumAddedToStart(data,taxon.getNumber()));		setBackground(ColorTheme.getContentBackground());		if (chroms != null){			chromSetPanel = new Panel();			add(chromSetPanel);			chromPanels = new BasicChromatogramPanel[chroms.length];			//chromVis = new boolean[chroms.length];			for (int i=0; i<chroms.length; i++){				//chromVis[i] = true;				chromPanels[i] = new BasicChromatogramPanel(this,chroms[i], this, i, id);				chromPanels[i].setVisible(true);				//	chromPanels[i].setBackground(Color.blue);				//addToWindow(chromPanels[i]);				chromSetPanel.add(chromPanels[i]);				totalPeakDistance+= chroms[i].getAveragePeakDistance();			}			peakDistance = totalPeakDistance/chroms.length;			}		aceContigPanel = new AceContigSeqPanel(this, contig, id);		aceContigPanel.setVisible(true);		aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(true);		add(aceContigPanel);		if (originalData != null){			originalSequence =new OrigSequenceImported(this,(MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData, contig, taxon.getNumber());			origSeqPanel = new OrigImportedSeqPanel(this, originalSequence, id);			origSeqPanel.setVisible(true);			add(origSeqPanel);		}		editedSequence =new EditedMatrixSequence(this,(MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData,  contig, taxon.getNumber());		matrixSeqPanel = new MatrixSequencePanel(this, editedSequence, id);		if (originalSequence == null)			originalSequence = editedSequence;		matrixSeqPanel.setVisible(true);		matrixSeqPanel.setBackground(Color.white);		add(matrixSeqPanel);		/*		 * 		if (data != null) {			data.addListener(editedSequence);			originalData.addListener(editedSequence);			qualityData.addListener(editedSequence);			data.addListener(originalSequence);			originalData.addListener(originalSequence);			qualityData.addListener(originalSequence);		}		 */		multiReadCallsPanel = new MultiReadCallsPanel(this,id,this, chroms);		multiReadCallsPanel.setVisible(true);		add(multiReadCallsPanel);		overviewPanel = new ContigOverviewPanel(this,id, this, chroms);		overviewPanel.setVisible(true);		add(overviewPanel);		bufferPanel = new Panel();		//bufferPanel.setBackground(Color.green);		bufferPanel.setVisible(true);		add(bufferPanel);		int numPeaksVisible = getApproximateNumberOfPeaksVisible();		centerBase = numPeaksVisible/2;		horizScrollPanel = new MesquitePanel();		horizScrollBar = new Scrollbar(Scrollbar.HORIZONTAL);		horizScrollBar.addAdjustmentListener(this);		horizScrollBar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumOverallBases() + numPeaksVisible/2); 		horizScrollBar.setUnitIncrement(1);		horizScrollBar.setBlockIncrement(1);//		hbar.addKeyListener(this);		horizScrollPanel.add("South",horizScrollBar);		//hbar.setVisible(true);		horizScrollPanel.setVisible(true);		horizScrollPanel.setBackground(Color.white);		add(horizScrollPanel);		vertScrollPanel = new MesquitePanel();		vertScrollBar = new Scrollbar(Scrollbar.VERTICAL);		vertScrollBar.addAdjustmentListener(this);		vertScrollBar.setValues(0,0,0,0); 		vertScrollBar.setUnitIncrement(1);		vertScrollBar.setBlockIncrement(1);		vertScrollPanel.add("EAST",vertScrollBar);		vertScrollPanel.setVisible(true);		vertScrollPanel.setBackground(Color.white);		add(vertScrollPanel);		Associable tInfo = data.getTaxaInfo(false);		numBasesOriginallyTrimmedFromStartOfPhPhContig = 0;		if (tInfo != null && taxon != null) {			int it = taxon.getNumber();			long t =	ChromaseqUtil.getLongAssociated(tInfo,ChromaseqUtil.startTrimRef, it);			if (MesquiteLong.isCombinable(t)) {				numBasesOriginallyTrimmedFromStartOfPhPhContig = (int)t;				padBeforeTrim = contig.resetPadding(numBasesOriginallyTrimmedFromStartOfPhPhContig, false);				numBasesOriginallyTrimmedFromStartOfPhPhContig -= padBeforeTrim;			}		}		synchChromToTable(true);		horizScrollBar.addKeyListener(this);						universalMapper = new ChromaseqUniversalMapper(this, data);		universalMapper.reset();	//	Debugg.println(chromaseqGraphicsMapper.toString());	}	public int getID(){		return id;	}		public ChromaseqUniversalMapper getUniversalMapper() {		return universalMapper;	}	public void setUpPrimers(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].setUpPrimers();			if (!MesquiteThread.isScripting())				chromPanels[i].repaintPanel();		}	}	public DNAData getEditedData() {		return data;	}	public BasicChromatogramPanel[] getChromPanels(){		return chromPanels;	}	public Chromatogram[] getChromatograms(){		return chromatograms;	}	public SequencePanel getAceContigPanel(){		return aceContigPanel;	}	public SequencePanel getMatrixSeqPanel(){		return matrixSeqPanel;	}	public SequencePanel getOrigSeqPanel(){		return origSeqPanel;	}	public MultiReadCallsPanel getMultiReadCallsPanel(){		return multiReadCallsPanel;	}	public ContigOverviewPanel getContigOverviewPanel(){		return overviewPanel;	}	public boolean extraContigsShown() {		return window.extraContigsShown();	}	public String[][] getPrimerSequences(){		MesquiteModule m = window.viewModule;		if (m instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){			mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)m;			return mod.getPrimerSequences();		}		return null;	}	public boolean showPrimers(){		return window.showPrimers();	}	public boolean getShowSinglePrimerMatch(){		return window.getShowSinglePrimerMatch();	}	public String getSinglePrimer(){		return window.getSinglePrimer();	}	public void setSequencesLocked(boolean seqLocked) {		locked = seqLocked;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		snapshot.addLine("showReversed " + showReversed.toOffOnString());		snapshot.addLine("showComplemented " + showComplemented.toOffOnString());		snapshot.addLine("setRelativeLockPos " + relativeLockPos);		return snapshot;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Shows sequence as reversed", "[]", commandName, "showReversed")) {			showReversed.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.reverseButton.setOptionDown(showReversed.getValue());		}		else if (checker.compare(this.getClass(), "Shows sequence as complemented", "[]", commandName, "showComplemented")) {			showComplemented.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.complementButton.setOptionDown(showComplemented.getValue());		}		else if (checker.compare(this.getClass(), "Toggles a chromatogram is visible ", "[number of chromatogram]", commandName, "toggleChromatVisible")) {			/*			int which = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(which) && which < chromVis.length && which >=0)				setChromatVisible(which, !chromVis[which]);			//sizePanels();			control.resize();			control.repaint();			 */		}		else if (checker.compare(this.getClass(), "Sets the relative lock position ", "[difference]", commandName, "setRelativeLockPos")) {			int pos = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(pos))				setRelativeLockPos(pos);		}		else if (checker.compare(this.getClass(), "Closes extra panel", "[]", commandName, "goAway")) {			window.removeContig(this);		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public void dispose(){		if (originalSequence!=null)			originalSequence.dispose();		if (editedSequence != null)			editedSequence.dispose();		super.dispose();	}	int relativeLockPos;	public int getRelativeLockPos(){		return relativeLockPos;	}	public void setRelativeLockPos(int p){		relativeLockPos = p;	}	public void setControl(ContigControlPanel c){		this.control = c;	}	public ContigControlPanel getControl(){		return control;	}	public void setLinker(ContigLinkerPanel c){		this.linker = c;	}	public ContigLinkerPanel getLinker(){		return linker;	}	public void setExplanation(String s){		window.setExplanation(s);	}	/*--------------------*/	public int getNumChromats(){		return chromPanels.length;	}	public int getChromatTop(int i){		if (i>=0 && i<chromPanels.length)			return chromPanels[i].getBounds().y;		return 0;	}	/*--------------------------------------*	public void setChromatVisible(int i, boolean v){		if (i>=0 && i<chromVis.length){			boolean ch = v != chromPanels[i].isOpen();			chromVis[i] = v;			control.resetButtons();			if (ch)				sizePanels();		}	}	/*--------------------------------------*/	public boolean getChromatVisible(int i){		if (i>=0 && i<chromPanels.length)			return chromPanels[i].isOpen();		return false;	}	public int getNumChromatVisible(){		int count = 0;		for (int i=0; i<chromPanels.length; i++)			if (chromPanels[i].isOpen())				count++;		return count;	}	//boolean[] chromVis;	final int closedHeight = 24;		/*--------------------------------------*/	public int getHorizontalScrollBarMaximum(){		if (horizScrollBar==null)			return 0;		return horizScrollBar.getMaximum();	}	/*--------------------------------------*/	public int getHorizontalScrollBarValue(){		if (horizScrollBar==null)			return 0;		return horizScrollBar.getValue();	}	/*--------------------------------------*/	/* Resize the chromatogram area and other components.*/	public void sizePanels(){		/* if chromatogramsOnTop then order is		 * 	overview		 * 	chromatograms		 * 	multiread		 * 	sequence		 * 		 * if not		 * 	overview		 * 	multiread		 * 	sequence		 * 	chromatograms		 * 			 * 			 */		//TODO: size panels		if (horizScrollPanel!=null)			horizScrollPanel.setVisible(false);		if (vertScrollPanel!=null)			vertScrollPanel.setVisible(false);		int border = 2;		int totalWidth = getWidth();//		int totalHeight = getHeight();		int belowOverviewTop = 0;		if (overviewPanel!=null) {			if (showOverviewPanel) {				overviewPanel.setBounds(border,0,totalWidth-border*2 ,overviewPanel.getRequestedHeight(totalWidth));				belowOverviewTop += overviewPanel.getRequestedHeight(totalWidth);			}			overviewPanel.setVisible(showOverviewPanel);		}		if (chromPanels==null)			return;		int singleChromatoHeight = 0;		if (getNumChromatVisible()>0) {			if (fixedChromatoHeight)				singleChromatoHeight = standardChromatoHeight ;			else				singleChromatoHeight = MesquiteInteger.maximum(minimumChromatoHeight,(getChromAreaHeight()-(chromPanels.length-getNumChromatVisible())*closedHeight)/getNumChromatVisible()) ;		}		int topOfChromatograms = belowOverviewTop;		if (!chromatogramsOnTop)			topOfChromatograms = getNonChromAreaHeight();		int topOfThisChromatogram = 0;		int totalChromatogramHeight = 0;		for (int i=0; i<chromPanels.length; i++){			int thisHeight = 0;			chromPanels[i].setStandardHeight(singleChromatoHeight);			thisHeight = chromPanels[i].getStandardHeight(); 			chromPanels[i].setBounds(border,topOfThisChromatogram, totalWidth-border*2, thisHeight -spacer);			chromPanels[i].setTop(topOfThisChromatogram);			topOfThisChromatogram += thisHeight;			totalChromatogramHeight+=thisHeight;			// chromPanels[i].setVisible((i+2)*chromatoHeight<getChromAreaHeight()+spacer+1 || i==0);		}		//int bottom = singleChromatoHeight*chromPanels.length + getNonChromAreaHeight();		int topOfSequencePanels = singleChromatoHeight*chromPanels.length+belowOverviewTop;		if (!chromatogramsOnTop)			topOfSequencePanels = belowOverviewTop;		else			if (topOfSequencePanels>getChromAreaHeight()+belowOverviewTop)				topOfSequencePanels=getChromAreaHeight()+belowOverviewTop;		int top = topOfSequencePanels;		if (chromatogramsOnTop) {			bufferPanel.setBounds(border,top,totalWidth-border*2,bufferHeight);			top += bufferHeight;		} 		if (multiReadCallsPanel!=null) {			if (showMultiReadCallsPanel) {				multiReadCallsPanel.setBounds(border,top,totalWidth-border*2 ,getMultiReadCallsPanelHeight());				top += getMultiReadCallsPanelHeight();			}			multiReadCallsPanel.setVisible(showMultiReadCallsPanel);		}		if (aceContigPanel!=null) {			if (showAceContigPanel) {				aceContigPanel.setBounds(border,top,totalWidth-border*2 ,seqPanelHeight);				top += seqPanelHeight;			}			aceContigPanel.setVisible(showAceContigPanel);		}		if (origSeqPanel!=null) { 			if (showOriginalImportPanel) {				origSeqPanel.setBounds(border,top,totalWidth-border*2,seqPanelHeight);				top += seqPanelHeight;			} 			origSeqPanel.setVisible(showOriginalImportPanel);		}		matrixSeqPanel.setBounds(border,top,totalWidth-border*2,seqPanelHeight);		top += seqPanelHeight;		if (horizScrollPanel!=null) {			horizScrollPanel.setBounds(border,getBounds().height-scrollDepth,totalWidth-border*2,scrollDepth);			horizScrollBar.setBounds(0,0,totalWidth-border*2,scrollDepth);			horizScrollPanel.setVisible(true);		}		int chromAreaHeight = getChromAreaHeight();		if (chromAreaHeight>getBounds().height - getNonChromAreaHeight() && chromatogramsOnTop)			chromAreaHeight = getBounds().height - getNonChromAreaHeight();		if (vertScrollPanel!=null) {			//vertScrollPanel.setBounds(getBounds().width-scrollDepth,topOfChromatograms,scrollDepth,getChromAreaHeight());			vertScrollPanel.setBounds(getBounds().width-scrollDepth,topOfChromatograms,scrollDepth,chromAreaHeight);			vertScrollBar.setBounds(0,0,scrollDepth,chromAreaHeight);			maxVertScroll = totalChromatogramHeight-chromAreaHeight;			if (maxVertScroll<0) 				maxVertScroll = 0;			int localMaxVertScroll = maxVertScroll;			int oldVertScrollPosition = vertScrollPosition;			vertScrollPosition = MesquiteInteger.minimum(vertScrollPosition, maxVertScroll);			vertScrollBar.setValues(vertScrollPosition, 0, 0,  maxVertScroll);			if (oldVertScrollPosition!=vertScrollPosition)				scrollVertically(vertScrollPosition);			vertScrollPanel.setVisible(true);			vertScrollBar.setUnitIncrement(10);			vertScrollBar.setBlockIncrement(getChromAreaHeight()/2);		}		chromSetPanel.setBounds(border,topOfChromatograms, totalWidth-border*2, chromAreaHeight);		//chromSetPanel.setBackground(Color.blue);		if (!chromatogramsOnTop) {			bufferPanel.setBounds(border,top,totalWidth-border*2,bufferHeight);			top += bufferHeight;		} 		if (horizScrollBar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			horizScrollBar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumOverallBases() + numPeaksVisible/2);// - numPeaksVisible -1);			int blockIncrement = numPeaksVisible/2-1;			if (blockIncrement<1)				blockIncrement=1;			horizScrollBar.setBlockIncrement(blockIncrement);		}	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setSize(int w, int h){		super.setSize(w,h);		sizePanels();		if (horizScrollBar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			horizScrollBar.setValues(centerBase,numPeaksVisible,numPeaksVisible/2,getTotalNumOverallBases() + numPeaksVisible/2);// - numPeaksVisible -1);			horizScrollBar.setBlockIncrement(numPeaksVisible);		}		if (vertScrollBar!=null) {			vertScrollBar.setValues(vertScrollPosition, getChromAreaHeight(), 0,  maxVertScroll);			vertScrollBar.setBlockIncrement(getChromAreaHeight()/2);		}	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return window.chromBoolean[window.COLORIMPORTEDBYQUALITY].getValue();	}	public boolean getColorReadCallsByQuality(){		return window.chromBoolean[window.COLORREADCALLSBYQUALITY].getValue();	}	public boolean getColorMultiReadByQuality(){		return window.chromBoolean[window.COLORMULTIREADCALLSBYQUALITY].getValue();	}	public boolean getColorOverviewByQuality(){		return window.chromBoolean[window.COLOROVERVIEWBYQUALITY].getValue();	}	public boolean getColorEditedInMatrixByQuality(){		return window.chromBoolean[window.COLOREDITEDINMATRIXBYQUALITY].getValue();	}	/*.................................................................................................................*/	public Color getBaseColor(char c, Color backgroundColor) {		switch (c) {		case 'A':			return getBaseColor(DNAState.A, backgroundColor);		case 'C':			return getBaseColor(DNAState.C, backgroundColor);		case 'G':			return getBaseColor(DNAState.G, backgroundColor);		case 'T':			return getBaseColor(DNAState.T, backgroundColor);		case 'a':			return getBaseColor(DNAState.A, backgroundColor);		case 'c':			return getBaseColor(DNAState.C, backgroundColor);		case 'g':			return getBaseColor(DNAState.G, backgroundColor);		case 't':			return getBaseColor(DNAState.T, backgroundColor);		case '-':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case '*':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case 'N':			return getBaseColor(DNAState.unassigned, backgroundColor);		case '?':			return getBaseColor(DNAState.unassigned, backgroundColor);		default:			return Color.darkGray;		}	}	/*.................................................................................................................*/	public Color getBaseColor(long c, Color backgroundColor) {		Color color = Color.darkGray;		if (c == DNAState.unassigned)			color = Color.darkGray;		else if (c == DNAState.inapplicable)			color =  Color.gray;		c = c & DNAState.statesBitsMask;		if (c == DNAState.A){ //should make this more efficient by using constants!			if (window.getUseSequencherColors())				color =  window.AColorSequencher;			else				color = window.AColorStandard;		}		else if (c == DNAState.C) {			if (window.getUseSequencherColors())				color =  window.CColorSequencher;			else				color = window.CColorStandard;		}		else if (c == DNAState.G) {			if (window.getUseSequencherColors())				color =  window.GColorSequencher;			else				color = window.GColorStandard;		}		else if (c == DNAState.T) {			if (window.getUseSequencherColors())				color =  window.TColorSequencher;			else				color = window.TColorStandard;		}		else if (c == (DNAState.A | DNAState.C | DNAState.G | DNAState.T)  )			color =  Color.darkGray;		if (backgroundColor.equals(color) && color.equals(Color.black))			color= Color.white;		return color;	}	/*.................................................................................................................*/	public Color getBackgroundColor() {		return window.getBackgroundColor();	}	public int getCenterBase(){		return centerBase;	}	public boolean isShownReversed(){		return showReversed.getValue();	}	public boolean isShownComplemented(){		return showComplemented.getValue();	}	//for coordinating selection	int firstTouched = MesquiteInteger.unassigned;	int secondTouched = MesquiteInteger.unassigned;	public void setFirstTouchedOverall(int ic){		firstTouched = ic;	}	public int getFirstTouchedOverall(){		return firstTouched;	}	public int getFirstTouchedConsensus(){		if (!MesquiteInteger.isCombinable(firstTouched))			return firstTouched;		int c =  getContigBaseFromUniversalBase(firstTouched);		if (c <0)			return 0;		return c;	}	public void setSecondTouchedOverall(int ic){		secondTouched = ic;	}	public int getSecondTouchedOverall(){		return secondTouched;	}	public int getSecondTouchedConsensus(){		if (!MesquiteInteger.isCombinable(secondTouched))			return secondTouched;		int c =  getContigBaseFromUniversalBase(secondTouched);		if (c <0)			return 0;		return c;	}	void setShowA(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowA(show);	}	void setShowC(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowC(show);	}	void setShowG(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowG(show);	}	void setShowT(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowT(show);	}	public void setScrollToTouched(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setScrollToTouched(s);		if (aceContigPanel!=null)			aceContigPanel.setScrollToTouched(s);		if (matrixSeqPanel!=null)			matrixSeqPanel.setScrollToTouched(s);		if (origSeqPanel!=null)			origSeqPanel.setScrollToTouched(s);		if (multiReadCallsPanel!=null)			multiReadCallsPanel.setScrollToTouched(s);	}	public void setShowBaseSource(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowBaseSource(s);	}	public void setShowCodonPosition(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowCodonPosition(s);	}	/*...............................................................................................................*/	public String getContigDisplayExplanation (int consensusBase){		StringBuffer sb = new StringBuffer();		sb.append("Consensus Base Quality: " + contig.getQualityOfBase(consensusBase));		if (window.chromBoolean[window.SHOWREADREADCONFLICT].getValue())			sb.append("\nRed/pink bar: two reads conflict. ");		if (window.chromBoolean[window.SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD].getValue())			sb.append("Box: source read is notably lower quality than other read. ");		return sb.toString();	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadName(showReadName);			}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowBaseNumberWithinRead(showBaseNumberWithinRead);			}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadMatrixConflict(show);			}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowReadReadConflict(show);	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		if (aceContigPanel!=null)			aceContigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		if (contig!=null)			contig.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimConflictMarkerThreshold(dimConflictMarkerThreshold);			}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		if (contig!=null)			contig.setDimLowQualityConflicts(dimLowQualityConflicts);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimLowQualityConflicts(dimLowQualityConflicts);			}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowFades(showFades);			}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeLowQuality(fadeLowQuality);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceRead(fadeNonSourceRead);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);			}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeQualityThreshold(fadeQualityThreshold);			}	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setThickTrace(thickTrace);			}	}	public void setUseSequencherColors(boolean useSequencherColors) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setUseSequencherColors(useSequencherColors);			}	}	/*.................................................................................................................*/	public void setColorImportedByQuality(boolean cbQ) {		if (aceContigPanel!=null)			aceContigPanel.setColorByQuality(cbQ);		if (origSeqPanel!=null)			origSeqPanel.setColorByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorEditedInMatrixByQuality(boolean colorMatrixbQ) {		if (matrixSeqPanel!=null)			matrixSeqPanel.setColorByQuality(colorMatrixbQ);	}	/*.................................................................................................................*/	public void setColorReadByQuality(boolean cReadbQ) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setColorByQuality(cReadbQ);			}	}	/*.................................................................................................................*/	public void setColorMultiReadByQuality(boolean cReadbQ) {		if (multiReadCallsPanel!=null)			multiReadCallsPanel.setColorByQuality(cReadbQ);	}	/*.................................................................................................................*/	public void setColorOverviewByQuality(boolean cReadbQ) {		if (overviewPanel!=null)			overviewPanel.setColorByQuality(cReadbQ);	}	/*.................................................................................................................*/	public double getHorizScale() {		return horizScale;	}	/*.................................................................................................................*/	public double getAveragePeakDistance() {		return (peakDistance * getHorizScale());	}	/*.................................................................................................................*/	public int getApproximateNumberOfPeaksVisible() {		if (getAveragePeakDistance()<=0)			return 0;		else			return (int)(getBounds().width/getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the number of pixels the window is scrolled */	public int getCenterPixelFromCenterBase(int centerBase){		return (int)((centerBase)*getAveragePeakDistance());	}	/*.................................................................................................................*/	public Contig getContig() {		return contig;	}	/*.................................................................................................................*/	public int getHorizontalPixels(int pixels) {		return (int)(pixels * getHorizScale());	}	void setMagnification(double mag){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setMagnification(mag);		}	}	void setShadowOffset(int o){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setShadowOffset(o);		}	}	void setShadowReduction(double o){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setShadowReduction(o);		}	}	public int getMultiReadCallsPanelHeight() {		if (multiReadCallsPanel!=null)			return multiReadCallsPanel.getRequestedHeight(getWidth());		return 0;	}	/*--------------------------------------*	public int getOverviewPanelHeight() {		if (overviewPanel!=null)			return overviewPanel.getAllReadHeight()+25;		return 0;	}	/*--------------------------------------*/	public int getNonChromAreaHeight(){		int part =  seqPanelHeight  + bufferHeight;		if (showAceContigPanel)			part += seqPanelHeight;		if (origSeqPanel!=null && showOriginalImportPanel) 			part += seqPanelHeight;		if (showMultiReadCallsPanel)			part += getMultiReadCallsPanelHeight();		if (showOverviewPanel && overviewPanel!=null)			part += overviewPanel.getRequestedHeight(getWidth());		return part;	}	/*--------------------------------------*/	public int getChromAreaHeight(){		int totalHeight = getHeight();		return totalHeight-getNonChromAreaHeight()-scrollDepth;	}	public SequencePanel getSequencePanel(int whichPanel){		if (whichPanel == 0)			return aceContigPanel;		else if (whichPanel == 1)			return origSeqPanel;		else if (whichPanel == 2)			return matrixSeqPanel;		return null;	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at consensus base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtConsensusPosition(int ic){		centerPanelsAtOverallPosition(getOverallBaseFromConsensusBase(ic));	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtOverallPosition(int ic){		centerPanelsAtOverallPosition(ic, true, false);	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtOverallPosition(int ic, boolean notifyWindow, boolean adjustScroll){//		Debugg.printStackTrace("center");		if (adjustScroll)			horizScrollBar.setValue(ic);		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].centerPanelAtOverallPosition(ic);  		}		if (aceContigPanel!=null)			aceContigPanel.centerPanelAtOverallPosition(ic);		matrixSeqPanel.centerPanelAtOverallPosition(ic);		if (origSeqPanel!=null)			origSeqPanel.centerPanelAtOverallPosition(ic);		if (multiReadCallsPanel!=null)			multiReadCallsPanel.centerPanelAtOverallPosition(ic);		if (overviewPanel!=null)			overviewPanel.centerPanelAtOverallPosition(ic);		centerBase = ic;		if (notifyWindow)			window.scrollsChanged(this, ic);	}	public int getHomePositionInMatrix(){		return getMatrixPositionOfUniversalBase(getContigBaseFromUniversalBase(centerBase), originalData);	}	/*--------------------------------------*/	public void focusMatrixOn(int ic1, int ic2){  //ic1 is the first touched read base (NOT consensus base); ic2 is the last touched base		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		if (!MesquiteInteger.isCombinable(ic1) && !MesquiteInteger.isCombinable(ic2))  // they are both unassigned, bail			return;		else if (MesquiteInteger.isCombinable(ic1) && ic1<0 && ic2<0)  // they are both <0, and so we don't want to move the matrix here			return;		else if (!MesquiteInteger.isCombinable(ic2) || (ic2<0) ||  ic2 == ic1){   // ic2 hasn't been assigned, or ic1 and ic2 are both positive and assigned			table.setFocusedCell(getMatrixPositionOfUniversalBase(ic1, originalData), it);		}		else {  //both are unassigned, and at least one is positive			table.setFocusedSequence(getMatrixPositionOfUniversalBase(ic1, originalData), getMatrixPositionOfUniversalBase(ic2, originalData), it);		}	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void synchChromToTable(boolean synchPosition){		if (!listen)			return;		if (!table.anyCellSelectedAnyWay())			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		//boolean currentCenterBaseIsSelected = table.isCellSelectedAnyWay(getMatrixPositionOfConsensusPosition( getConsensusBaseFromOverallBase(centerBase), originalData), it);		for (int universalBase =0; universalBase<universalMapper.getNumUniversalBases(); universalBase++) { 		//	int consensusBase = getConsensusBaseFromOverallBase(universalBase);//			int mPos = getMatrixPositionOfConsensusBase(consensusBase, originalData);						int matrixBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase);			boolean sel = table.isCellSelectedAnyWay(matrixBase, it);			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = universalBase;				lastSel = universalBase;				blockEnded = false;			} 			//else if (firstSel != -1){   //DRM 24 April 2008:  turned this off			//	blockEnded = true;			//}			changed = setSelectedUniversalBaseInChrom(universalBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void matrixChanged(boolean synchPosition){		//synchChromToTable(synchPosition);   // DRM turned this off 24 April 2008, as it forces the selection in the matrix to take precedent over that in chromaseq		repaintPanels();	}		/*--------------------------------------*/	public boolean getSelectedAnyChromatogram(int overallBase){		for (int i=0; i<chromPanels.length; i++){			if (chromPanels[i].getSelected(overallBase))				return true;		}		return false;	}	/*--------------------------------------*/	public void synchTableToChrom(boolean synchPosition){		if (!listen)			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		for (int universalBase =0; universalBase<universalMapper.getNumUniversalBases(); universalBase++) { 			boolean sel = getSelectedAnyChromatogram(universalBase);	//		int consensusBase = getConsensusBaseFromOverallBase(universalBase);		//	int mPos = getMatrixPositionOfConsensusBase(consensusBase, originalData); //Wayne: use this to then select table			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = universalBase;				lastSel = universalBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}			changed = setSelectedUniversalBaseInChrom(universalBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToOverallBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	void selectedToGaps(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int universalBase = 0; universalBase< universalMapper.getNumUniversalBases(); universalBase++){			if (getSelectedDisplayPositionInChrom(universalBase))				((DNAData)data).setState(universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase), it, CategoricalState.inapplicable);		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		data.notifyInLinked(new Notification(MesquiteListener.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void trimmableToGaps(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int ic = 0; ic< originalData.getNumChars(); ic++){			if (ChromaseqUtil.isTrimmable(ic,it,data))				((DNAData)data).setState(ic, it, CategoricalState.inapplicable);		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void selectedToRevert(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int ic = 0; ic< getTotalNumOverallBases(); ic++){			if (getSelectedDisplayPositionInChrom(ic)){				int icc = getMatrixPositionOfUniversalBase(ic, originalData);				((DNAData)data).setState(icc, it, ((DNAData)originalData).getStateRaw(icc, it));			}		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfConsensusBase(int ic){		int basesFromLeftSide = getOverallBaseFromConsensusBase(ic);   // now adjust for the fact that the consensus sequence may not start at 0, 		// as there may be excess on the left		return (int)(basesFromLeftSide*getAveragePeakDistance());	}	/*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfDIsplayBase(int ic){		// as there may be excess on the left		return (int)(ic*getAveragePeakDistance());	}	/*--------------------------------------*/	public long getMatrixStateLongAtDisplayPosition(int ic){		if (taxon == null)			return '-';		int icM = getMatrixPositionOfUniversalBase(ic);		int it = taxon.getNumber();			return data.getState(icM, it);	}	/*--------------------------------------*/	public char getMatrixStateAtConsensusBase(int ic){		if (taxon == null)			return '-';		int icM = getMatrixPositionOfUniversalBase(ic);		int it = taxon.getNumber();			return DNAData.getIUPACChar(data.getState(icM, it));	}	/*--------------------------------------*/	public char getMatrixStateAtUniversalBase(int ic){		if (taxon == null || universalMapper == null)			return '-';		int icM = universalMapper.getEditedMatrixBaseFromUniversalBase(ic);		int it = taxon.getNumber();			return DNAData.getIUPACChar(data.getState(icM, it));	}	/*--------------------------------------*/	public boolean getSelectedUniversalBase(int universalBase){		if (selectedUniversalBase != null && universalBase>=0 && universalBase<selectedUniversalBase.length)			return selectedUniversalBase[universalBase];		return false;	}	/*--------------------------------------*/	public boolean setSelectedUniversalBaseInChrom(int universalBase, boolean sel, boolean repnt){		if (!listen)			return false;		boolean changed = false;		if (selectedUniversalBase==null || selectedUniversalBase.length!=universalMapper.getNumUniversalBases()){			selectedUniversalBase = new boolean [universalMapper.getNumUniversalBases()];			for (int i=0; i<selectedUniversalBase.length; i++)				selectedUniversalBase[i]=false;		}		if (universalBase>=0 && universalBase<selectedUniversalBase.length)			selectedUniversalBase[universalBase]= sel;		for (int i=0; i<chromPanels.length; i++){			changed = chromPanels[i].selectUniversalPositionInChrom(universalBase, sel, repnt) || changed;		}		changed = aceContigPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		changed = matrixSeqPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		if (origSeqPanel!=null)			changed = origSeqPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		return changed;	}	/*--------------------------------------*/	//this is consensus position	public void selectDisplayPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, i);		//	int ic = getMatrixPositionOfConsensusBase(i, originalData);			int it = taxon.getTaxa().whichTaxonNumber(taxon);//			originalSequence.dumpFirstPositions();			table.selectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	//this is consensus position	public void deselectDisplayPositionInTable(int i){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, i);		//	int ic = getMatrixPositionOfConsensusBase(i, originalData);			table.deselectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	public void deselectAllInTable(){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			for (int ic = 0; ic<table.getNumColumns(); ic++){				table.deselectCell(ic, it);				table.redrawCell(ic, it);			}		}		listen = true;	}	public void deselectAllInPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}		aceContigPanel.deselectAll();		matrixSeqPanel.deselectAll();		if (origSeqPanel!=null)			origSeqPanel.deselectAll();	}	public void deselectAllReads(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}	}	public void deselectAllChrom(int overallBase){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll(overallBase);		}	}	/*--------------------------------------*	public void switchView(){		/*			 for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setVisible(viewChromatograms.getValue());			}			aceContigPanel.setVisible(viewChromatograms.getValue());			matrixSeqPanel.setVisible(viewChromatograms.getValue());			if (origSeqPanel!=null)				origSeqPanel.setVisible(viewChromatograms.getValue());	 */	/*--------------------------------------*/	public void repaintPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].repaintPanel();		}		aceContigPanel.repaintPanel();		matrixSeqPanel.repaintPanel();		if (origSeqPanel!=null)			origSeqPanel.repaintPanel();	}	/*--------------------------------------*/	public boolean oneSelectedForEditing(){		if (matrixSeqPanel==null)			return false;		if (!matrixSeqPanel.isVisible())			return false;		return matrixSeqPanel.oneSelected();	}	/*--------------------------------------*/	public Taxon getTaxon(){		return taxon;	}	int keys = 0;	public void keyReleased(KeyEvent e){	}	public void keyTyped(KeyEvent e){	}	public void keyPressed(KeyEvent e){		int k = e.getKeyCode();		if (k==KeyEvent.VK_LEFT) {			checkToDeselect();			if (window.chromBoolean[window.JUMPTONEXTBASE].getValue())				scrollToConsensusBaseOffset(-1);  //David: deselect any selection			else 				goToNextProblem(false, false);		}		else if (k==KeyEvent.VK_RIGHT) {			checkToDeselect();			if (window.chromBoolean[window.JUMPTONEXTBASE].getValue())				scrollToConsensusBaseOffset(1);  //David: deselect any selection			else 				goToNextProblem(true, false);		}	}	/*.................................................................................................................*/ 	public void checkToDeselect(){		if (window.chromBoolean[window.TURNOFFEDITONMOVE].getValue() && oneSelectedForEditing())			deselectAllInPanels();	}	/*.................................................................................................................*/ 	private int nextLowQuality(boolean right, int threshold) {		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					int qual = contig.getQualityOfBase(i);					if (qual<threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextAmbiguity(boolean right) {  // next ambiguity either in the matrix base or the original Phred.Phrap.Mesquite calls		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					long contigBase = getMatrixStateLongAtDisplayPosition(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}					contigBase = contig.getBase(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					long contigBase = getMatrixStateLongAtDisplayPosition(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}					contigBase = contig.getBase(i);					if (CategoricalState.hasMultipleStates(contigBase)) {						return i;					}				}			}		return -1;	}	public boolean baseCalled(int i) {		int it = data.getTaxa().whichTaxonNumber(getTaxon());		int ic = getMatrixPositionOfUniversalBase(i, data);		if (it>=0)			if (ChromaseqUtil.baseCalled(getMatrixPositionOfUniversalBase(i, data), it , data))				return true;		return false;	}	private boolean checkForBaseCalled(int i) {		boolean bc = baseCalled(i);		boolean b2 = window.getIgnoreProblemIfBaseCalled();		return (!window.getIgnoreProblemIfBaseCalled()|| !baseCalled(i));	}	/*.................................................................................................................*/ 	private int nextSourceReadIsLowerQualityAndConflicts(boolean right, int smallConflictThreshold, int largeConflictThreshold, boolean strongly) {		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextSourceReadIsLowerQuality(boolean right, int smallConflictThreshold, int largeConflictThreshold) {		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts,largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadReadConflict(boolean right, int threshold) {		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					int conflict = contig.getConflictLevel(i);					if (conflict>=threshold)						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextDoublePeak(boolean right, int threshold) {   //threshold is quality threshold		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		MesquiteDouble fraction = new MesquiteDouble(0.0);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);					Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {						Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());//						highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);					Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {						Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());//						highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadMatrixConflict(boolean right, int threshold) {		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromContigBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusBase(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		else			for (int i=centerConsensusBase+1;i < contig.getLength();i++) {				if (i>=0 && checkForBaseCalled(i)) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int readBase = read.getReadBaseFromContigBase(i);						char c = read.getPhdBaseChar(readBase);						char contigBase = getMatrixStateAtConsensusBase(i);						if (c!=contigBase) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return i;						}					}				}			}		return -1;	}	/*.................................................................................................................*/	private void goToNextProblem(boolean right, boolean major) {					int next = -1;		int next2 = -1;		if (window.chromBoolean[window.JUMPTONEXTAMBIGUITY].getValue()) {			next2 = nextAmbiguity(right);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTLOWQUALITY].getValue()) {			next2 = nextLowQuality(right, window.chromInt[window.JUMPQUALITYTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTREADMATRIXCONFLICT].getValue()) {			next2 = nextReadMatrixConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTREADREADCONFLICT].getValue()) {			next2 = nextReadReadConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTBADSOURCEREAD].getValue()) {			next2 = nextSourceReadIsLowerQualityAndConflicts(right, 1, 20, major);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}				/*		boolean jumpToNextDoublePeak = true;		if (jumpToNextDoublePeak) {			next2 = nextDoublePeak(right, 20);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}				 */		/*		Debugg.println("||||||||||||||||||||||||||||");		for (int i=0;i < contig.getLength();i++) {				StringBuffer b = new StringBuffer();				b.append("  " + i + "          ");				for (int r=0; r<contig.getNumReadsToShow(); r++) {					Read read = contig.getRead(r);					int iBase = read.getReadBaseFromConsensusBase(i);					if (iBase>=0 && iBase<=read.getBasesLength()) {						double candidateFraction = read.getSecondaryPeakFraction(iBase);						int candidatePeakQuality =  read.getPhdBaseQuality(iBase);						b.append("     /     " + candidateFraction + "     " + candidatePeakQuality);					}				}				Debugg.println(b.toString());		}		 */		//Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	private void goToNextReadReadConflict(boolean right) {		int nextLow = nextReadReadConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextAmbiguity(boolean right) {		int next = nextAmbiguity(right);//		Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<contig.getLength()) {			scrollToConsensusBase(next);		}	}	/*.................................................................................................................*/	private void goToNextLowQuality(boolean right) {		int nextLow = nextLowQuality(right, window.chromInt[window.JUMPQUALITYTHRESHOLD].getValue());//		Debugg.println("nextLow: " + nextLow);		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextReadMatrixConflict(boolean right) {		int nextLow = nextReadMatrixConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());		if (nextLow>=0 && nextLow<contig.getLength()) {			scrollToConsensusBase(nextLow);		}	}	/*--------------------------------------*/	public  void scrollToOverallBase(int overallBase){		if (!MesquiteInteger.isCombinable(overallBase))			overallBase = 0;		horizScrollBar.setValue(overallBase);		centerPanelsAtOverallPosition(overallBase);	}	/*--------------------------------------*/	public  void scrollToConsensusBase(int i){		scrollToOverallBase(getOverallBaseFromConsensusBase(i));	}	/*--------------------------------------*/	public  void scrollToMatrixBase(int i){		scrollToConsensusBase(getConsensusPositionOfMatrixPosition(i));	}	/*--------------------------------------*/	public  void scrollToConsensusBaseOffset(int i){		int newBase = centerBase+i;		if (newBase>=0 && newBase<getTotalNumOverallBases()) {						horizScrollBar.setValue(newBase);			centerPanelsAtOverallPosition(newBase);		}	}	/*--------------------------------------*/	public void scrollVertically(int value) {		vertScrollBar.setValue(value);		vertScrollPosition = value;		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].adjustTop(vertScrollPosition);		}	}	/*--------------------------------------*/	public  void adjustmentValueChanged(AdjustmentEvent evt){		if(evt.getAdjustable() == horizScrollBar) {			switch(evt.getAdjustmentType()) {			case AdjustmentEvent.UNIT_DECREMENT:			case AdjustmentEvent.UNIT_INCREMENT:			case AdjustmentEvent.BLOCK_INCREMENT:			case AdjustmentEvent.BLOCK_DECREMENT:			case AdjustmentEvent.TRACK:				centerPanelsAtOverallPosition(evt.getValue());				checkToDeselect();				break;			}		}		else	if(evt.getAdjustable() == vertScrollBar) {			switch(evt.getAdjustmentType()) {			case AdjustmentEvent.UNIT_DECREMENT:			case AdjustmentEvent.UNIT_INCREMENT:			case AdjustmentEvent.BLOCK_INCREMENT:			case AdjustmentEvent.BLOCK_DECREMENT:			case AdjustmentEvent.TRACK:				scrollVertically(evt.getValue());				break;			}		}	}	public boolean isShowAceContigPanel() {		return showAceContigPanel;	}	public void setShowAceContigPanel(boolean showAceContigPanel) {		this.showAceContigPanel = showAceContigPanel;	}	public boolean isShowOriginalImportPanel() {		return showOriginalImportPanel;	}	public void setShowOriginalImportPanel(boolean showOriginalImportPanel) {		this.showOriginalImportPanel = showOriginalImportPanel;	}	public boolean isChromatogramsOnTop() {		return chromatogramsOnTop;	}	public void setChromatogramsOnTop(boolean chromatogramsOnTop) {		this.chromatogramsOnTop = chromatogramsOnTop;	}	public boolean isFixedChromatoHeight() {		return fixedChromatoHeight;	}	public void setFixedChromatoHeight(boolean fixedChromatoHeight) {		this.fixedChromatoHeight = fixedChromatoHeight;	}	public boolean isShowMultiReadCallsPanel() {		return showMultiReadCallsPanel;	}	public void setShowMultiReadCallsPanel(boolean showMultiReadCallsPanel) {		this.showMultiReadCallsPanel = showMultiReadCallsPanel;	}	public void setShowOverviewPanel(boolean showOverviewPanel) {		this.showOverviewPanel = showOverviewPanel;	}	public ClosablePanel getPrecedingPanel(ClosablePanel panel) {		/*	if (panel==null) return null;		if (panel.equals(overviewPanel))			return null;		else if (chromatogramsOnTop){			if (panel.equals(multiReadCallsPanel)){				if (chromPanels.length>0)					return chromPanels[chromPanels.length-1];			}			else {				for (int i=0; i<chromPanels.length; i++) {					if (panel.equals(chromPanels[i])) {						if (i==0) {							if (showOverviewPanel)								return overviewPanel;							else								return null;						} else							return chromPanels[i-1];					}				}			}		}		else {			if (panel.equals(multiReadCallsPanel)){				if (showOverviewPanel)					return overviewPanel;			}			else {				for (int i=0; i<chromPanels.length; i++) {					if (panel.equals(chromPanels[i])) {						if (i==0) {							if (showMultiReadCallsPanel)								return multiReadCallsPanel;							else if (showOverviewPanel)								return overviewPanel;							else								return null;						} else							return chromPanels[i-1];					}				}			}		}		 */		return null;	}	public void requestHeightChange(ClosablePanel panel){		sizePanels();		repaint();	}							/* |||||||||||||||||   BASE COORDINATION SECTION |||||||||||||||||||||| */	/* this section helps with the coordination and registration between bases and peeks, in the matrices, the chromatagrams and phred/phrap output, and the display	 * see the start of ChromaseqBaseMapper for more information */		/*.................................................................................................................*/	/** Adds to the numBasesAddedToStart in the Contig.   */	public void addToNumBasesAddedToStart(int i){		 getContig().addToNumBasesAddedToStart(i);	}	/*.................................................................................................................*/	public void setNumBasesAddedToStart(int numBasesAddedToStart) {		getContig().setNumBasesAddedToStart(numBasesAddedToStart);	}	/*.................................................................................................................*/	public int getNumBasesAddedToStart() {		return getContig().getNumBasesAddedToStart();	}	/*.................................................................................................................*/	/** Returns the base number in the display at the base baseNumber in the overall base system.   */	public int getDisplayBaseFromOverallBase(int baseNumber){		return baseNumber;	}	/*.................................................................................................................*/	/** Returns the base number in the overall base system at the base baseNumber in the display system.   */	public int getOverallBaseFromDisplayBase(int baseNumber){		return baseNumber;	}	/*.................................................................................................................*/	/** Returns the base number within the consensus sequence at the base baseNumber (which is numbered from the beginning, including excess bases at the start).   */	public int getContigBaseFromUniversalBase(int universalBase){		if (!MesquiteInteger.isCombinable(universalBase))			return universalBase;				return universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, universalBase);	//	return universalBase-contig.getReadExcessAtStart();//-numBasesOriginallyTrimmedFromStartOfPhPhContig+getNumBasesAddedToStart();	}	/*.................................................................................................................*/	public int getOverallBaseFromConsensusBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.ACEFILECONTIG, baseNumber);	//	return baseNumber+contig.getReadExcessAtStart();//+numBasesOriginallyTrimmedFromStartOfPhPhContig-getNumBasesAddedToStart();	}	/*.................................................................................................................*/	public int getTotalNumOverallBases() {		int numPeaks = contig.getNumBases() + contig.getReadExcessAtStart()+ contig.getReadExcessAtEnd();//		Debugg.println("|||| totalNumPeaks: " + numPeaks + ", numBases: " + contig.getNumBases()+ ", excessAtStart: " + contig.getReadExcessAtStart()+ ", excessAtEnd: " + contig.getReadExcessAtEnd());		return numPeaks;	}	/*--------------------------------------*/	/** This returns the number of padded bases before consensus site ic  */	public int getNumPaddedBeforeDisplayBase(int ic){		return getContig().getNumPaddedBefore(ic);	}	/*--------------------------------------*/	/** This returns the number of padded bases before consensus site ic  */	public int getNumPaddedBeforeEditedBase(int ic){				int startOfEdited = getNumBasesOriginallyTrimmedFromStartOfPhPhContig()-getNumBasesAddedToStart();		int numPaddedBeforeStartOfEdited =0;		if (startOfEdited>=0)			numPaddedBeforeStartOfEdited = getContig().getNumPaddedBefore(startOfEdited);		else startOfEdited=0;		return getContig().getNumPaddedBefore(startOfEdited + ic)-numPaddedBeforeStartOfEdited;	}	/*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedBeforeDisplayBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfUniversalBase(ic-1);		int icmAfter = getMatrixPositionOfUniversalBase(ic);		if (icmBefore<0 || icmAfter<0|| !MesquiteInteger.isCombinable(icmBefore) || !MesquiteInteger.isCombinable(icmAfter)) 			return 0;		if (icmAfter-icmBefore <=1)			return 0;		if (taxon == null)			return 0;		if (icmBefore==0 && icmAfter!=0) //there is an added base just before this one.			return 1;		if (icmAfter==0 && icmBefore!=0) //this is an added base.			return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	/*--------------------------------------*/	/** This returns the number of  bases inserted into the matrix between consensus site ic-1 and ic  */	public int getNumInsertedAfterDisplayBase(int ic){		if (ic <= 0)			return 0;		int icmBefore = getMatrixPositionOfUniversalBase(ic);		int icmAfter = getMatrixPositionOfUniversalBase(ic+1);		if (icmAfter-icmBefore <=1)			return 0;		if (icmBefore==0 && icmAfter!=0) //this is an added base.			return 0;		if (icmAfter==0 && icmBefore!=0) //there is an added base just after this one.			return 1;		if (taxon == null)			return 0;		int it = taxon.getNumber();				int count = 0;		for (int i = icmBefore +1; i< icmAfter; i++){			if (!data.isInapplicable(i, it))				count++;		}		return count;	}	public int getSpaceInsertedAfterDisplayBase(int ic){		int numInserted = getNumInsertedAfterDisplayBase(ic);		if (numInserted>0)			return (int)(getAveragePeakDistance()*numInserted);		return 0;	}	public int getSpaceInsertedBeforeDisplayBase(int ic){		int numInserted = getNumInsertedBeforeDisplayBase(ic);		if (numInserted>0)			return (int)(getAveragePeakDistance()*numInserted);		return 0;	}	public int getTotalSpaceInsertedBeforeDisplayBase(int ic){		int total = 0;		for (int i = 0; i<=ic; i++){			total+= getNumInsertedBeforeDisplayBase(i);		}		return (int)(total*getAveragePeakDistance());	}	/*.................................................................................*/		/** This should return for site ic in the untrimmed, unpadded Contig the 	 * number in the untrimmed, PADDED contig. */		private int getConsensusFromUnpaddedUntrimmed(int ic){		return getContig().getPaddedSiteFromUnpaddedSite(ic);	}		/*.................................................................................................................*/	public  int numPadsInTrimmedRegionAtStart(int it) {		return padBeforeTrim;	}	/*--------------------------------------*/	/** This should return for overall site ic what codon position the site is. */	public int  getCodonPositionOfOverallBase(int overallBase){		if (data==null)			return 0;	//	int consensusBase = getContigBaseFromUniversalBase(overallBase);		int matrixCharacter = getMatrixPositionOfUniversalBase(overallBase, data);		if (matrixCharacter>=0 && matrixCharacter<data.getNumChars())			return data.getCodonPosition(matrixCharacter);		else			return 0;	}		/*.................................................................................*/	public int getMatrixPositionOfUniversalBase(int universalBase){		return getMatrixPositionOfUniversalBase(universalBase, originalData);	}	/*.................................................................................*/		/** This should return for consensus site ic what character in matrix it corresponds to.  	 * This is needed in case the sequence has been aligned,	 * and thus is not left justified and contiguous.  It also accounts for the trimming that is done in going from 	 * the consensus (i.e., main contig) sequence to the sequence in the matrix. */	public int getMatrixPositionOfUniversalBase(int universalBase, DNAData data){		if (taxon == null || universalMapper==null)			return -1;		int it = taxon.getNumber();		return universalMapper.getEditedMatrixBaseFromUniversalBase(universalBase);/*		sequencePosition -= getNumPaddedBeforeDisplayBase(consensusBase);		sequencePosition -= numBasesOriginallyTrimmedFromStartOfPhPhContig;		sequencePosition += getNumBasesAddedToStart(); 		sequencePosition = editedSequence.matrixBaseFromSequenceBase(sequencePosition);		return sequencePosition;		*/	}		/*.................................................................................*/	public int getConsensusBaseFromContigBase(int ic){		return ic+ numBasesOriginallyTrimmedFromStartOfPhPhContig;	}	/*.................................................................................*/	public int getNumBasesOriginallyTrimmedFromStartOfPhPhContig(){		return numBasesOriginallyTrimmedFromStartOfPhPhContig;	}	/*.................................................................................*/	public int getConsensusPositionOfMatrixPosition(int ic){		return getConsensusPositionOfMatrixPosition(ic, originalData);	}	/*.................................................................................*/	/*@@@@@@@@@This should return for character ic in the edited matrix the position in the consensus sequence (i.e., the untrimmed, padded Contig)	 * This is needed in case the sequence has been aligned,	 and thus is not left justified and contiguous.  This has access to both the data and table @@@@@@@@@@@*/	public int getConsensusPositionOfMatrixPosition(int ic, DNAData data){				int sequencePosition = editedSequence.sequenceBaseFromMatrixBase(ic);  // this is the position in the editedSequence 		if (!MesquiteInteger.isCombinable(sequencePosition)){			return ic;		}				int consensusPosition = sequencePosition+getNumBasesOriginallyTrimmedFromStartOfPhPhContig()-getNumBasesAddedToStart();//		consensusPosition+= getNumPaddedBeforeEditedBase(sequencePosition);//-numPadsInTrimmedRegionAtStart(getTaxon().getNumber());		return consensusPosition;	}	/*--------------------------------------*/	/*This uses indices as in consensus*/	public boolean getSelectedDisplayPositionInChrom(int ic){		return matrixSeqPanel.getSelectedConsensus(ic);	}	/*.................................................................................*/	public boolean getSelectedOverallBase(int overallBase) {		return chromPanels[0].getSelected(overallBase);	}	/* |||||||||||||||||   END BASE COORDINATION SECTION |||||||||||||||||||||| */}